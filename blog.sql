/*
Navicat MySQL Data Transfer

Source Server         : root
Source Server Version : 80019
Source Host           : localhost:3306
Source Database       : blog

Target Server Type    : MYSQL
Target Server Version : 80019
File Encoding         : 65001

Date: 2020-07-10 15:30:18
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for article
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(50) NOT NULL COMMENT '文章标题',
  `description` text COMMENT '文章描述',
  `author` varchar(50) DEFAULT NULL COMMENT '文章作者',
  `content` longtext COMMENT '文章内容',
  `read_num` int DEFAULT '0' COMMENT '阅读量',
  `comment_num` int DEFAULT '0' COMMENT '评论量',
  `like_num` int DEFAULT '0' COMMENT '点赞量',
  `recommend` tinyint(1) DEFAULT '0' COMMENT '是否推荐文章',
  `type_Id` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL DEFAULT '1' COMMENT '文章类型',
  `publish` tinyint NOT NULL DEFAULT '0' COMMENT '发布状态',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8 COMMENT='文章';

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('8', '数据结构--动态数组ArrayList ', '学习记录，本篇主要内容是Java实现动态数组', '九曜', '\n◼ **数据结构是计算机存储、组织数据的方式。是指相互之间存在一种或多种特定关系的数据元素的集合**。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200225161612993.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n◼精心选择的数据结构可以带来更高的运行或者存储效率，所以在实际应用中，往往会根据使用场景来选择最合适的数据结构。\n\n----\n◼线性表是最基本、最简单、也是最常用的一种数据结构（数组，链表，栈，队列，哈希表等）。\n\n#### 线性表是具有n个相同类型元素的有限序列（n>=0）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020022516223573.png)\n*a1是首节点（首元素），an是尾结点（尾元素）\na1是a2的前驱，而a2是a1的后继*\n\n----\n**◼数组是一种顺序存储的线性表，所有元素的内存地址是连续的。**\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200225170732778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n\n----\n在很多编程语言中，数组都有个致命的缺点，那就是无法动态修改容量\n实际开发中，我们更希望数组的容量是可以动态改变的。而JDK也内置了动态数组java.util.ArrayList\n\n## 动态数组 设计：\nsize：元素个数；\nelements：所有的元素\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200225174732490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\n  // 元素的数量\n	private int size;\n	// 所有的元素\n	private E[] elements;//使用泛型来表示数组类型，从而能保证复用性\n	//默认容量\n	private static final int DEFAULT_CAPACITY = 10;\n	//索引错误值\n	private static final int ELEMENT_NOT_FOUND = -1;\n	//有参构造方法 如果赋值小于默认容量值 则选取默认容量来构造数组\n	public ArrayList(int capaticy) {\n		capaticy = (capaticy < DEFAULT_CAPACITY) ? DEFAULT_CAPACITY : capaticy;\n		elements = (E[]) new Object[capaticy];\n	}\n	//无参构造 就是构造默认容量动态数组\n	public ArrayList() {\n		this(DEFAULT_CAPACITY);\n	}\n```\n◼void  add(E element);// 添加元素到最后面 \n思路：将新元素添加到数组的size位置上, size++\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020022517494343.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\n\n	public void add(E element) {\n		add(size, element);\n	}\n```\n◼void   add(intindex, E element);// 往index位置添加元素\n思路：将index之后的元素往后移动，则会空出index位置空间\n移动时先要**从后向前**移动元素，如果**从前向后**移动元素, 那么会进行元素覆盖\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200225174957693.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\n	public void add(int index, E element) {\n		rangeCheckForAdd(index);\n		ensureCapacity(size + 1);\n		for (int i = size; i > index; i--) {\n			elements[i] = elements[i - 1];\n		}\n		elements[index] = element;\n		size++;\n	}\n\n```\n◼E  remove(intindex);// 删除index位置对应的元素\n思路：将index后面元素前移顺序覆盖，size--\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200225174834796.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\n	public E remove(int index) {\n		rangeCheck(index);\n		E old = elements[index];\n		for (int i = index + 1; i < size; i++) {\n			elements[i - 1] = elements[i];\n		}\n		elements[--size] = null;\n		return old;\n	}\n```\n◼E  get(intindex);// 返回index指定索引位置对应的元素\n```\n	public E get(int index) {\n		rangeCheck(index);\n		return elements[index];\n	}\n```\n◼E  set(intindex, E element);// 设置index位置的元素\n```\n	public E set(int index, E element) {\n		rangeCheck(index);\n		E old = elements[index];\n		elements[index] = element;\n		return old;\n	}\n```\n◼int  indexOf(E element);// 查看元素的位置\n    可以通过循环, 查找元素在数组中的位置\n```\n	public int indexOf(E element) {\n	    //设计的动态数组允许null值\n		if (element == null) {\n			for (int i = 0; i < size; i++) {\n				if (elements[i] == null) return i;\n			}\n		} else {\n			for (int i = 0; i < size; i++) {\n				if (element.equals(elements[i])) return i;\n			}\n		}\n		return ELEMENT_NOT_FOUND;\n	}\n```\n◼void  clear();// 清除所有元素，将所有的元素置为null, 然后size置为0\n```\n	public void clear() {\n		for (int i = 0; i < size; i++) {\n			elements[i] = null;\n		}\n		size = 0;\n	}\n```\n◼void ensureCapacity(int capacity)；//扩容 保证容量\n思路：复制：新建一个新的动态数组，将旧数组数据插入新数组即可\n\n采用位运算是为了提高运算效率，因为取模，乘除等运算比较浪费性能\n\n须注意的是在扩容和缩容中要注意**复杂度震荡**\n如果他们的相乘是1（扩容的新容量是旧容量的2倍，缩容的容量也压缩2倍，那就是2*1/2=1），就会频繁触发复杂度震荡，所以这里采用的是扩容1.5倍，缩容一半就是缩两倍，以此避免复杂度震荡。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200225175037971.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\n	private void ensureCapacity(int capacity) {\n		int oldCapacity = elements.length;\n		if (oldCapacity >= capacity) return;\n		// 新容量为旧容量的1.5倍 ，位运算则每左移一位，相当于该数乘以2\n		int newCapacity = oldCapacity + (oldCapacity >> 1);\n		E[] newElements = (E[]) new Object[newCapacity];\n		for (int i = 0; i < size; i++) {\n			newElements[i] = elements[i];\n		}\n		elements = newElements;\n		System.out.println(oldCapacity + \"扩容为\" + newCapacity);\n	}\n	\n```\n◼void trim()；//缩容为了减小浪费内存，其思路与扩容相同\n\n```\n		private void trim() {\n		int oldCapacity = elements.length;\n		int newCapacity = oldCapacity >> 1;\n		if (size > (newCapacity) || oldCapacity <= DEFAULT_CAPACITY) return;\n		E[] newElements = (E[]) new Object[newCapacity];\n		for (int i = 0; i < size; i++) {\n			newElements[i] = elements[i];\n		}\n		elements = newElements;	\n		System.out.println(oldCapacity + \"缩容为\" + newCapacity);\n	}\n```\n◼检查索引及处理（抛异常）索引检查是为了防止索引不能越界, 即不能小于0, 也不能大于等于size。\n```\nprivate void outOfBounds(int index) {\n        //当用户传索引值不对时，我们对它的处理是抛异常\n		throw new IndexOutOfBoundsException(\"Index:\" + index + \", Size:\" + size);\n	}\n	//检查索引正确方法\n	private void rangeCheck(int index) {\n		if (index < 0 || index >= size) {\n			outOfBounds(index);\n		}\n	}\n	//这是对添加方法设计的检查索引方法\n	private void rangeCheckForAdd(int index) {\n		if (index < 0 || index > size) {\n			outOfBounds(index);\n		}\n	}\n```\n◼toString等其他方法\n```\n   // 元素的数量  \n    public int size() {\n		return size;\n	}\n   // 是否为空 ，size==0即无任务元素\n	public boolean isEmpty() {\n		 return size == 0;\n	}\n   // 是否包含某个元素\n   //思路：用indexOf()查询索引 ，若索引为-1，则不存在。\n	public boolean contains(E element) {\n		return indexOf(element) != ELEMENT_NOT_FOUND;\n	}\n	//重写toString方法将元素拼接成字符串打印输出\n    @Override\n	public String toString() {\n		StringBuilder string = new StringBuilder();//字符串拼接建议使用StringBuilder\n		string.append(\"size=\").append(size).append(\", [\");\n		for (int i = 0; i < size; i++) {\n			if (i != 0) {\n				string.append(\", \");\n			}	\n			string.append(elements[i]);	\n		}\n		string.append(\"]\");\n		return string.toString();\n	}\n	\n```\n\n\n', '100', '2', '88', '1', '1', '0', '2020-06-29 14:28:23', '2020-06-29 14:28:23');
INSERT INTO `article` VALUES ('9', '数据结构--链表Linked List', '学习记录，本篇主要内容是Java实现链表', '九曜', '◼链表（Linked List）\n上篇的动态数组有个明显的缺点，会造成内存空间的大量浪费。但链表可以做到用到多少就申请多少内存，从而减小内存的浪费。\n\n##### 链表是一种链式存储的线性表，所有元素的内存地址不一定是连续的\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226164412295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)**◼接口设计**\n链表的大部分接口和动态数组是一致的\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226164903872.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)LinkedList类，用来管理链表，size属性记录存储数据的数量，first属性则是引用链表的第0个元素。\nNode结点类，其中的element属性用于存储元素，next属性记录下一个节点的地址，用于指向链表中的下一个节点。\n```\npublic class SingleLinkedList<E> extends AbstractList<E> {\n    private Node<E> first;\n	    private static class Node<E>{\n		    E element;\n		    Node<E> next;\n		    public Node(E element, Node<E> next) {\n			     this.element = element;\n			     this.next = next;\n		   }	\n	} \n```\n链表的创建与动态数组不同，动态数组在构造时需要传入一个容量初始值，来决定这个数组的容量。但链表元素是在添加时才创建的，内存地址不一定是连续的。所以链表不需要在单独设计构造方法，使用默认构造方法即可。\n◼添加元素 - add(int index,E element)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226165915509.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\npublic void add(int index, E element) {\n		rangeCheckForAdd(index);// 检查索引是否越界\n		if(index==0) {//往第一个位置添加\n		// 创建新节点并next指向原位置节点new Node<>(element,prve.next);\n		//最后first指向新节点\n		first = new Node<>(element, first);\n		}else {\n			Node<E> prve=node(index-1);// 找到指定位置前面的节点\n			// 创建新节点并next指向原位置节点new Node<>(element,prve.next);\n			//最后前节点prev的next指向新节点，完成桥接\n			prve.next=new Node<>(element,prve.next);\n		}\n		size++;\n	}\n```\n*在编写链表过程中，要注意边界测试，比如index为0 、size–1、size* \n在添加删除等操作时，我们需要获得index添加位置的节点\n◼node(int index) //获取index位置对应的节点对象。\n```\nprivate Node<E> node(int index){\n		rangeCheck(index);// 检查索引是否越界\n		Node<E> node = first;//从第一个开始循环遍历\n		for(int i=0;i<index;i++) {\n			node=node.next;\n		}\n		return node;\n	}\n```\n◼删除元素-remove(int index)；\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226171514124.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)删除节点比较容易，越过指定位置节点即可（prev.next=node.next;），\n即指定位置的上一节点直接指向下一节点。\n```\npublic E remove(int index) {\n		rangeCheck(index);\n		Node<E> node = first;\n		if(index==0) {//当只有一个元素时\n			first=null;\n		}else {\n			Node<E> prev=node(index-1);\n			node = prev.next;\n			prev.next=node.next;	\n		}\n		size--;\n		return node.element;\n	}\n```\n-----\n可以发现，我们每次操作都需要考虑边界值，特别是第一个节点。\n**◼如果为了让代码更加精简，统一所有节点的处理逻辑，可以在最前面增加一个虚拟的头结点（不存储数据）**\n这样我们的代码就不需要考虑第一个节点，为它单独操作。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226172337659.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n\n-----\n◼**双向链表** JDK 中的java.util.LinkedList内置的就是双向链表\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226173338363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n◼构造方法改为：多了一个prev属性，指向前一个节点的地址\n\n```\nprivate Node<E> first;\n	private Node<E> last;\n	private static class Node<E>{\n		E element;\n		Node<E> next;\n		Node<E> prev;\n		public Node(Node<E> prev,E element, Node<E> next) {\n			this.prev=prev;\n			this.element = element;\n			this.next = next;\n		}	\n	}\n```\n◼node方法改为：用折半方法遍历，提高效率\n```\n    /**\n	 * 获取index位置对应的节点对象\n	 */\n	private Node<E> node(int index){\n		rangeCheck(index);\n		//折半查找\n		if(index<size>>1) {\n			Node<E> node = first;\n			for(int i=0;i<index;i++) {\n				node=node.next;\n			}\n			return node;\n		}else {\n			Node<E> node = last;\n			for(int i=size;i>index;i--) {\n				node=node.prev;\n			}\n			return node;\n		}\n	}\n```\n◼双向链表–add(int index, E element）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200226174132801.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)以添加中间位置为例：\nNode<E> next=node(index);//得到指定位置的节点，也就是之后的下一个节点\nNode<E> prev=next.prev;;//指定位置的上一个节点，也就是之后的上一个节点\nNode<E> node=new Node<>(prev,element,next);//新节点新建时就完成了指向\nnext.prev=node//下一个节点指向新节点\nprev.next=node;//上一个节点指向新节点\n```\npublic void add(int index, E element) {\n		rangeCheckForAdd(index);\n		if(index == size) { // 往最后面添加元素\n			Node<E> oldLast = last;\n			last = new Node<>(oldLast, element, null);\n			if (oldLast == null) { // 这是链表添加的第一个元素\n				first = last;\n			} else {\n				oldLast.next = last;\n			}\n		}else {\n			Node<E> next=node(index);\n			Node<E> prev=next.prev;\n			Node<E> node=new Node<>(prev,element,next);\n			next.prev=node;\n			if(index==0) {//prev=null\n				first=node;\n			}else {\n				prev.next=node;\n			}\n		}\n		size++;\n	}\n```\n◼双向链表 - remove(int index)\n也是以删除中间位置为例\nNode<E> prev = node.prev;//得到指定位置的上节点\nNode<E> next = node.next;//得到指定位置的下节点\nprev.next = next;//prev.next指向next节点，越过node节点\nnext.prev = prev;//next.prev指向prev节点，不与原本的node相连\n```\n	public E remove(int index) {\n		rangeCheck(index);\n		Node<E> node = node(index);\n		Node<E> prev = node.prev;\n		Node<E> next = node.next;\n		if (prev == null) { // index == 0\n			first=next;\n		}else {\n			prev.next = next;\n		}	\n	    if (next == null) { // index == size - 1\n	    	last = prev;\n	    }\n	    else {\n	    	next.prev = prev;\n		}\n		size--;\n		return node.element;\n	}\n```\n◼动态数组：开辟、销毁内存空间的次数相对较少，但可能造成内存空间浪费（可以通过缩容解决）\n◼双向链表：开辟、销毁内存空间的次数相对较多，但不会造成内存空间的浪费\n\n◼如果频繁在尾部进行添加、删除操作，动态数组、双向链表均可选择\n◼如果频繁在头部进行添加、删除操作，建议选择使用双向链表\n◼如果有频繁的（在任意位置）添加、删除操作，建议选择使用双向链表◼如果有频繁的查询操作（随机访问操作），建议选择使用动态数组\n\n\n\n\n\n\n\n', '56', '1', '44', '0', '3', '0', '2020-06-29 14:31:38', '2020-06-29 14:31:38');
INSERT INTO `article` VALUES ('10', '数据结构--栈Stack和队列Queue', '学习记录，本篇主要内容是Java实现栈', '九曜', '\n#### ◼栈是一种特殊的线性表，只能在一端进行操作\n●往栈中添加元素的操作，一般叫做push，入栈\n●从栈中移除元素的操作，一般叫做pop，出栈（只能移除栈顶元素，也叫做：弹出栈顶元素）\n●后进先出的原则，Last In First Out，LIFO（类似于火车高铁进出站）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200227160539283.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n栈的内部实现可以使用动态数组、链表等数据结构\n\n##### ◼栈的接口设计：\n\n●int size();// 元素的数量\n●boolean isEmpty();// 是否为空\n●void push(E element);// 入栈\n●E pop();// 出栈\n●E top();// 获取栈顶元素\n●void clear();// 清空栈底栈顶\n\n直接使用之前的动态数组或者链表\n```\npublic class Stack<E>  {\n	List<E> list = new ArrayList<>(); \n	// 元素的数量\n	public int size() {\n		return list.size();\n	}\n	// 是否为空\n	public boolean isEmpty() {\n		return list.isEmpty();\n	}\n	// 入栈\n	public void push(E element) {\n		list.add(element);\n	}\n	// 出栈\n	public E pop() {\n		return list.remove(list.size()-1);\n	}\n	//换取栈顶元素\n	public E top() {\n		return list.get(list.size()-1);\n	}\n```\n浏览器的前进和后退，或者软件的撤销（Undo）、恢复（Redo）功能就是使用了栈来实现的（两个栈结构）。\n*●后退操作图*\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200227164003478.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)每次当前访问的页面都是栈顶元素，后退则是将当前页面放入另一个空栈中记录下来，该操作是为了前进操作返回页面元素做准备，防止页面丢失前进不了。\n*●前进操作图*\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200227163445457.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)●若访问新网站，需要将右栈清空，放弃无用元素。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200227163035259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n\n-----\n#### ◼队列是一种特殊的线性表，只能在头尾两端进行操作\n\n●队尾（rear）：只能从队尾添加元素，一般叫做enQueue，入队\n●队头（front）：只能从队头移除元素，一般叫做deQueue，出队\n●先进先出的原则，First In First Out，FIFO\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020022716442626.png)\n**◼队列的接口设计：**\n●int size();// 元素的数量\n●boolean isEmpty();// 是否为空\n●void clear();// 清空\n●void enQueue(E element);// 入队\n●E deQueue();// 出队\n●E front();// 获取队列的头元素\n●动态数组、链表都可以实现队列，但优先使用双向链表，因为队列主要是往头尾操作元素\n\n```\npublic class Queue<E> {\n	private List<E> list = new LinkedList<E>();\n	// 元素的数量\n	public int size() {\n		return list.size();\n	}\n    //清空\n	public void clear() {\n		list.clear();\n	}\n	// 是否为空\n	public boolean isEmpty() {\n		return list.isEmpty();\n	}\n	// 入队\n	public void enQueue(E element) {\n		list.add(element);\n	};\n	// 出队\n	public E deQueue() {\n		return list.remove(0);\n	}\n	public E front() {\n		return list.get(0);\n	}\n}\n\n```\n\n#### ◼循环队列（Circle Queue）\n\n◼其实队列底层也可以使用动态数组实现，并且各项接口也可以优化到O(1) 的时间复杂度，这个用数组实现并且优化之后的队列也叫做：**循环队列**  ，底层用**数组**实现。\n假设初始循环队列，多了一个队头属性记录着头元素的下标。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200228151631538.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)出队\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020022815162270.png)入队\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200228151533422.png)\n◼数组实现循环队列\n```\npublic class CircleQueue<E> {\n	private int front;//队头下标\n	private int size;//元素数量\n	private E[] elements;//所有的元素\n	private static final int DEFAULT_CAPACITY = 10;//默认大小\n	//构造函数创建默认大小队列存储元素\n	public CircleQueue() {\n		elements = (E[]) new Object[DEFAULT_CAPACITY];\n	}\n	// 元素的数量，直接返回size\n	public int size() {\n		return size;\n	}\n	// 是否为空，size为0即队列是空的\n	public boolean isEmpty() {\n		return size==0;\n	}\n	//清空，front属性清空，循环队列全部置为null，size=0\n	public void clear() {\n		front=0;\n		for(int i=0;i<size;i++) {\n			elements[i]=null;\n		}\n		size=0;\n	}	\n	// 入队\n	public void enQueue(E element) {\n		ensureCapacity(size+1);//保证队列容量\n		//elements[队尾位置 size]=element（入队元素值）\n		elements[index(size)]=element;\n		size++;\n	};	\n	// 出队\n	public E deQueue() {\n		E frontElement = elements[front];//记录出队元素\n		elements[front] = null;//队列【队头位置】=null清空\n		front = index(1);//队头下标+1\n		size--;\n		return frontElement;\n	}	\n	//查看队头元素\n	public E front() {\n		return elements[front];\n	}\n	//输出打印方法\n	public String toString() {\n		StringBuilder string = new StringBuilder();\n		string.append(\"capcacity=\").append(elements.length)\n		.append(\" size=\").append(size)\n		.append(\" front=\").append(front)\n		.append(\", [\");\n		for (int i = 0; i < elements.length; i++) {\n			if (i != 0) {\n				string.append(\", \");\n			}\n			string.append(elements[i]);\n		}\n		string.append(\"]\");\n		return string.toString();\n	}\n	//索引映射封装方法\n	private int index(int index) {\n		return（front+index）%elements.length；\n	}\n	/**\n	 * 保证要有capacity的容量\n	 * @param capacity\n	 */\n	private void ensureCapacity(int capacity) {\n		int oldCapacity = elements.length;\n		if (oldCapacity >= capacity) return;\n		// 新容量为旧容量的1.5倍\n		int newCapacity = oldCapacity + (oldCapacity >> 1);\n		E[] newElements = (E[]) new Object[newCapacity];\n		for (int i = 0; i < size; i++) {\n			newElements[i] = elements[index(i)];\n		}\n		elements = newElements;\n		// 重置front\n		front = 0;\n	}\n		\n}\n```\n◼%运算符优化\n●尽量避免使用乘*、除/、模%、浮点数运算，效率低下\n```\nprivate int index(int index) {\n		index += front;\n		//（front+index）%elements.length\n		return index - (index >= elements.length ? elements.length : 0);\n	}\n```\n●已知n>=0，m>0 ，n%m等价于n –(m > n ? 0 : m) 的前提条件：**n < 2m**\n\n\n\n\n\n\n', '69', '3', '66', '0', '2', '0', '2020-06-29 14:33:11', '2020-06-29 14:33:11');
INSERT INTO `article` VALUES ('11', '数据结构--二叉树', '学习记录，本篇主要内容是二叉树基本概念', '九曜', '\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200301154309176.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n**◼树（Tree）的基本概念**\n●节点、根节点、父节点、子节点、兄弟节点，一棵树可以没有任何节点，称为空树，一棵树可以只有1 个节点，也就是只有根节点\n●子树：左子树、右子树\n●节点的度（degree）：子树的个数\n●树的度：所有节点度中的最大值\n●叶子节点（leaf）：度为0 的节点\n●非叶子节点：度不为0 的节点\n●层数（level）：根节点在第1 层，根节点的子节点在第2 层，以此类推（有些教程也从第0 层开始计算）\n●节点的深度（depth）：从根节点到当前节点的唯一路径上的节点总数\n●节点的高度（height）：从当前节点到最远叶子节点的路径上的节点总数\n●树的深度：所有节点深度中的最大值\n●树的高度：所有节点高度中的最大值\n●树的深度等于树的高度\n●有序树：树中任意节点的子节点之间有顺序关系\n●无序树：树中任意节点的子节点之间没有顺序关系也称为“自由树”\n●森林：由m（m ≥0）棵互不相交的树组成的集合\n\n----\n**◼二叉树（Binary Tree）**\n◼二叉树的特点：\n●每个节点的度最大为2（最多拥有2 棵子树）\n●左子树和右子树是有顺序的\n●即使某节点只有一棵子树，也要区分左右子树\n●二叉树是有序树还是无序树？有序树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200301155128751.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n**◼二叉树的性质**\n●非空二叉树的第i层，最多有2i−1个节点（i≥1）\n●在高度为h的二叉树上最多有2h−1个结点（h≥1）\n●对于任何一棵非空二叉树，如果叶子节点个数为n0，度为2 的节点个数为n2，则有: n0 = n2 + 1\n：假设度为1 的节点个数为n1，那么二叉树的节点总数n= n0 + n1 + n2\n二叉树的边数T = n1 + 2 * n2 = n –1 = n0 + n1 + n2 –1\n因此**n0 = n2 + 1**\n**◼真二叉树：**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200301155010245.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n**◼满二叉树（Full Binary Tree）**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200301155049400.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n\n\n**◼完全二叉树（Complete Binary Tree）**\n●叶子节点只会出现最后2 层，且最后1 层的叶子结点都靠左对齐\n●完全二叉树从根结点至倒数第2 层是一棵满二叉树\n●满二叉树一定是完全二叉树，完全二叉树不一定是满二叉树\n![◼完全二叉树：](https://img-blog.csdnimg.cn/20200301155215437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n●度为1 的节点只有左子树\n●度为1 的节点要么是1 个，要么是0 个\n●同样节点数量的二叉树，完全二叉树的高度最小\n●假设完全二叉树的高度为h（h≥1），那么\n●至少有2h−1个节点（20+21+22+⋯+2h−2+1）\n●最多有2h−1个节点（20+21+22+⋯+2h−1，满二叉树）\n●总节点数量为n\n✓2h−1≤n<2h\n✓h−1≤log2n<h\n✓h=floor(log2n)+1\n➢floor 是向下取整，另外，ceiling 是向上取整\n**◼判断一棵树是否为完全二叉树**\n●如果树为空，返回false\n●如果树不为空，开始层序遍历二叉树（用队列）\n●如果node.left!=null，将node.left 入队\n●如果node.left==null && node.right!=null，返回false\n●如果node.right!=null，将node.right 入队\n●如果node.right=null\n✓那么后面遍历的节点应该都为叶子节点，才是完全二叉树\n✓否则返回false\n●遍历结束，返回true\n\n```\n//是否为完全二叉树\n	public boolean isComplete() {\n		if(root==null) return false;//树为空，不是完全二叉树\n		//如果树不为空，开始层序遍历二叉树（用队列）\n		Queue<Node<E>> queue = new LinkedList<>();\n		queue.offer(root);//根节点入队\n		boolean leaf = false;//叶子节点\n		//层序遍历二叉树\n		while(!queue.isEmpty()) {\n			Node<E> node=queue.poll();\n			if (leaf && !node.isLeaf()) return false;//叶子节点判断\n			if(node.hasTwoChildren()) {//度为2的节点\n				queue.offer(node.left);\n				queue.offer(node.right);\n			}else if(node.left==null && node.right!=null) {\n				return false;//左子树为空，而右子树不为空，不是完全二叉树\n			}else {后面遍历的节点应该都为叶子节点，才是完全二叉树\n				leaf = true;\n			}\n		}\n		return true;//遍历结束，返回true\n	}\n```\n----\n**◼二叉树的遍历**\n遍历是数据结构中的常见操作，就是把所有元素都访问一遍。\n**◼前序遍历--递归（Preorder Traversal）**\n●访问顺序：根节点、前序遍历左子树、前序遍历右子树\n●遍历顺序结果：7、4、2、1、3、5、9、8、11、10、12\n前序遍历应用：树状结构展示（注意左右子树的顺序）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200301160850196.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\npublic void preorderTraversal() {\n	preorderTraversal(root);\n}\nprivate void preorderTraversal(Node<E> node) {\n	if (node == null) return;\n	//递归\n    System.out.println(node.element);\n    preorderTraversal(node.left);\n    preorderTraversal(node.right);\n}\n```\n◼前序遍历--非递归方法1\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200315150144443.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\n    //1\n	public void preorder1(Visitor<E> visitor) {\n		if(root == null || visitor ==null) return;\n		Node<E> node = root;\n		Stack<Node<E>> stack = new Stack<>();\n		while(true) {\n			if(node !=null) {\n				//访问node节点\n				if(visitor.visit(node.element)) return;\n				//将右子节入栈\n				if(node.right!=null) {\n					stack.push(node.right);\n				}\n				//向左走\n				node = node.left;\n			}else if(stack.isEmpty()) {\n				return;\n			}else {\n				node = stack.pop();\n			}\n		}\n	}\n```\n◼前序遍历--非递归方法2\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200315150743207.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\n\npublic void preorder(Visitor<E> visitor) {\n		if(root == null || visitor ==null) return;\n		Stack<Node<E>> stack = new Stack<>();\n		stack.push(root);\n		while(!stack.isEmpty()) {\n			Node<E> node=stack.pop();\n			visitor.visit(node.element);\n			if(node.right!=null) {\n				stack.push(node.right);\n			}\n			if(node.left!=null) {\n				stack.push(node.left);\n			}\n		}\n	}\n```\n**◼中序遍历--递归（Inorder Traversal）**\n●访问顺序：中序遍历左子树、根节点、中序遍历右子树\n●遍历顺序结果：1、2、3、4、5、7、8、9、10、11、12\n中序遍历应用：二叉搜索树的中序遍历按升序或者降序处理节点\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200301161210925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n◼如果访问顺序是下面这样呢？\n●中序遍历右子树、根节点、中序遍历左子树\n●12、11、10、9、8、7、5、4、3、2、1\n◼二叉搜索树的中序遍历结果是升序或者降序的\n\n```\npublic void inorderTraversal() {\n  inorderTraversal(root);\n}\n	private void inorderTraversal(Node<E> node) {\n		if (node == null) return;\n        inorderTraversal(node.left);\n		System.out.println(node.element);\n		inorderTraversal(node.right);\n  }\n```\n◼中序遍历--非递归\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200315150552941.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\npublic void inorder(Visitor<E> visitor) {\n		if(root == null || visitor ==null) return;\n		Node<E> node = root;\n		Stack<Node<E>> stack = new Stack<>();\n		\n		while(true) {\n			if(node!=null) {\n				stack.push(node);//将根节点或者左节点入栈\n				node = node.left;\n			}else if(stack.isEmpty()) {\n				return;\n			}else {\n				node = stack.pop();\n				//访问node节点\n				if(visitor.visit(node.element)) return;\n				//让右节点进行中序遍历\n				node = node.right;\n			}\n		}\n	}\n```\n**◼后序遍历--递归（Postorder Traversal）**\n●访问顺序：后序遍历左子树、后序遍历右子树、根节点\n●遍历顺序结果：1、3、2、5、4、8、10、12、11、9、7\n◼后序遍历应用：适用于一些先子后父的操作\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200301161549774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\npublic void postorderTraversal() {\n	postorderTraversal(root);\n}\n	private void postorderTraversal(Node<E> node) {\n	if (node == null) return;\n		postorderTraversal(node.left);\n	   postorderTraversal(node.right);\n		System.out.println(node.element);\n	}\n```\n◼后序遍历--非递归\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200315150414337.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\npublic void postorder(Visitor<E> visitor) {\n		if(root == null || visitor ==null) return;\n		Node<E> prev= null;\n		Stack<Node<E>> stack = new Stack<>();\n		stack.push(root);\n		while(!stack.isEmpty()) {\n			Node<E> top = stack.peek();\n			if(top.isLeaf() || (prev !=null && prev.parent==top)) {\n				prev = stack.pop();\n				//访问节点\n				if(visitor.visit(prev.element)) return;\n			}else {\n				if(top.right!=null) {\n					stack.push(top.right);\n				}\n				if(top.left !=null) {\n					stack.push(top.left);\n				}\n			}\n		}\n		\n	}\n```\n**◼层序遍历（Level Order Traversal）**\n●访问顺序：从上到下、从左到右依次访问每一个节点\n●遍历顺序结果：7、4、9、2、5、8、11、1、3、10、12\n◼层序遍历应用：计算二叉树的高度和判断一棵树是否为完全二叉树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200301161806710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n◼实现思路：使用队列\n1.将根节点入队\n2.循环执行以下操作，直到队列为空\n●将队头节点A 出队，进行访问\n●将A 的左子节点入队\n●将A 的右子节点入队\n\n```\npublic void levelOrderTraversal() {\n		if (root == null) return;\n	    Queue<Node<E>> queue = new LinkedList<>();\n	    queue.offer(root);\n	    while (!queue.isEmpty()) {\n			Node<E> node = queue.poll();\n		System.out.println(node.element);\n		if (node.left != null) {\n			queue.offer(node.left);\n		}\n		if (node.right != null) {\n			queue.offer(node.right);\n		}\n		}\n}\n```\n**◼根据遍历结果重构二叉树**\n以下结果可以保证重构出唯一的一棵二叉树\n●前序遍历+ 中序遍历\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200301162254271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n红色方块为根节点，先利用前序遍历特性判断出根节点（第一个即为根节点），拿到根节点依据中序遍历锁定左右子树。再次循环判断左右子树的根节点，不断循环即可。\n●后序遍历+ 中序遍历，同理\n◼前序遍历+ 后序遍历\n✓如果它是一棵真二叉树（度为2或者度为0），结果是唯一的\n✓不然结果不唯一\n\n----\n\n**◼前驱节点（predecessor）**\n●前驱节点：中序遍历时的前一个节点\n●如果是二叉搜索树，前驱节点就是前一个比它小的节点\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200301162832657.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n◼node.left!= null\n举例：6、13、8\npredecessor= node.left.right.right.right...\n✓终止条件：right 为null\n\n◼node.left== null && node.parent!= null\n举例：7、11、9、1\npredecessor= node.parent.parent.parent...\n✓终止条件：node 在parent 的右子树中\n\n◼node.left== null && node.parent== null\n那就没有前驱节点\n举例：没有左子树的根节点\n```\nprivate Node<E> predecessor(Node<E> node) {\n		if (node == null) return null;\n		// 前驱节点在左子树当中（left.right.right.right....）\n		Node<E> p = node.left;\n		if (p != null) {\n			while (p.right != null) {\n				p = p.right;\n			}\n			return p;\n		}\n		// 从父节点、祖父节点中寻找前驱节点\n		while (node.parent != null && node == node.parent.left) {\n			node = node.parent;\n		}\n		// node.parent == null 和 node == node.parent.right\n		return node.parent;\n	}\n```\n**◼后继节点（successor）**\n●后继节点：中序遍历时的后一个节点\n●如果是二叉搜索树，后继节点就是后一个比它大的节点\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200301163355335.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n◼node.right!= null\n举例：1、8、4\nsuccessor= node.right.left.left.left...\n✓终止条件：left 为null\n\n◼node.right== null && node.parent!= null\n举例：7、6、3、11\nsuccessor= node.parent.parent.parent...\n✓终止条件：node 在parent 的左子树中\n\n◼node.right== null && node.parent== null\n那就没有前驱节点\n举例：没有右子树的根节点\n```\nprivate Node<E> successor(Node<E> node) {\n		if (node == null) return null;\n		//后继节点在右子树当中（right.left.left.left....）\n		Node<E> p = node.right;\n		if (p != null) {\n			while (p.left != null) {\n				p = p.left;\n			}\n			return p;\n		}\n		// 从父节点、祖父节点中寻找后继节点\n		while (node.parent != null && node == node.parent.right) {\n			node = node.parent;\n		}\n		return node.parent;\n	}\n```\n**◼计算二叉树的高度**\n●递归\n```\npublic int height() {\n		return height(root);\n	}\n	节点的高度时左右子树的高度+1\n	private int height(Node<E> node) {\n		if (node == null) return 0;\n		return 1 + Math.max(height(node.left), height(node.right));\n	}\n```\n\n●迭代\n利用层序遍历，每遍历一层，高度+1\n\n```\npublic int height() {\n		if (root == null) return 0;\n		// 树的高度\n		int height = 0;\n		// 存储着每一层的元素数量\n		int levelSize = 1;\n		Queue<Node<E>> queue = new LinkedList<>();\n		queue.offer(root);\n		while (!queue.isEmpty()) {\n			Node<E> node = queue.poll();\n			levelSize--;\n			if (node.left != null) {\n				queue.offer(node.left);\n			}\n			if (node.right != null) {\n				queue.offer(node.right);\n			}\n			if (levelSize == 0) { // 意味着即将要访问下一层\n				levelSize = queue.size();\n				height++;\n			}\n		}\n		return height;\n	}\n```\n\n', '68', '4', '66', '1', '2', '0', '2020-06-29 14:34:22', '2020-06-29 14:34:22');
INSERT INTO `article` VALUES ('12', '数据结构--二叉搜索树', '学习记录，本篇主要内容是二叉搜索树', '九曜', '\n**◼二叉搜索树（Binary Search Tree）**\n二叉搜索树是二叉树的一种，是应用非常广泛的一种二叉树，英文简称为BST，又被称为：二叉查找树、二叉排序树。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200302151441277.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n●任意一个节点的值都**大**于其左子树所有节点的值\n●任意一个节点的值都**小**于其右子树所有节点的值\n●它的左右子树也是一棵二叉搜索树\n●二叉搜索树可以大大提高搜索数据的效率\n●二叉搜索树存储的元素必须具备**可比较性**，比如int、double等\n●如果是自定义类型，需要指定比较方式，不允许为**null**\n\n◼二叉搜索树的接口设计\n●int size()// 元素的数量\n●boolean isEmpty()// 是否为空\n●void clear()// 清空所有元素\n●void add(E element)// 添加元素\n●void remove(E element)// 删除元素\n●boolean contains(E element)// 是否包含某元素\n●需要注意的是，对于我们现在使用的二叉树来说，它的元素没有索引的概念\n\n*简单的继承结构*\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200302155834448.png)\n----\n\n### ◼添加节点\n\n![比如添加12、1](https://img-blog.csdnimg.cn/20200302152034181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)按照：任意一个节点的值都**大**于其左子树所有节点的值\n任意一个节点的值都**小**于其右子树所有节点的值的原则，进行添加节点。\n\n```\n// 添加元素\n	public void add(E element) {\n		//判断元素是否为null\n		elementNotNullCheck(element);\n		//添加是否是根节点 第一个节点\n		if(root==null) {\n			root = new Node<> (element,null); //创建根节点\n			size++;\n			return ;\n		}\n		// 添加的不是第一个节点\n		// 找到父节点 \n		Node<E> parent = root;\n		Node<E> node = root;\n		int cmp=0;\n		while(node!=null) {\n			cmp=compare(element,node.element);//比较\n			parent = node;//父节点\n			if(cmp>0) {\n				node = node.right;\n			}else if(cmp<0) {\n				node = node.left;\n			}else {//相等\n				node.element = element;//覆盖旧值\n				return;\n			}\n		}\n		//创建新节点\n		Node<E> newNode = new Node<E>(element,parent);\n		//看看插入到父节点的哪个位置\n		//parent.left=node 或者parent.right=node\n		if(cmp>0) {\n			parent.right=newNode;\n		}else {\n			parent.left=newNode;\n		}\n		size++;\n	}\n	private void elementNotNullCheck(E element) {\n		if(element==null) {\n			throw new IllegalArgumentException(\"element must not be null\");\n		}\n	}\n```\n\n而想进行添加节点，就必须进行比较元素的大小，这也是上面提到的，二叉搜索树存储的元素必须具备**可比较性**，比如int、double等。\n**◼元素的比较方案设计**\n●1.允许外界传入一个Comparator 自定义比较方案\n●2.如果没有传入Comparator，强制认定元素实现了Comparable 接口\n```\n      /*\n       *构造方法\n       */\n     public BinarySearchTree() {\n		this(null);\n	}\n	// 是否包含某元素\n	public boolean contains(E element) {\n		return node(element) != null;\n	}\n	public BinarySearchTree(Comparator<E> comparator) {\n		this.comparator = comparator;//外界传递的自定义比较器\n	}\n     /**\n	 * @return 返回值等于0，代表e1和e2相等；返回值大于0，代表e1大于e2；返回值小于于0，代表e1小于e2\n	 */\n	private int compare(E e1, E e2) {\n		//先调用比较器\n		if(comparator !=null) {\n			return comparator.compare(e1, e2);\n		}\n		//若无比较器，则默认可以比较，强制转化，  因为二叉搜索树默认需要可比较性\n		return ((Comparable<E>)e1).compareTo(e2);\n	}\n```\n◼根据元素内容获取节点\n采用遍历二叉树，比较其值，相等则有值获取返回\n```\n//节点node方法 利用元素寻找节点    \n	private Node<E> node(E element){\n		Node<E> node=root;\n		while(node!=null) {\n			int cmp = compare(element, node.element);\n			if(cmp==0) {\n				return node;\n			}else if(cmp>0) {\n				node=node.right;\n			}else {\n				//cmp<0\n				node=node.left;\n			}\n		}\n		return null;\n	}\n```\n\n### ◼删除\n\n**◼删除节点–叶子节点**\n●直接删除：3，5，8，10，7\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200302154640421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n**◼删除节点–度为1的节点**\n●用子节点替代原节点的位置\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200302154940686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)**◼删除节点–度为2的节点**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200302155551526.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n◼举例：先删除5、再删除4\n●先用前驱或者后继节点的值覆盖原节点的值\n●然后删除相应的前驱或者后继节点\n●如果一个节点的度为2，那么它的前驱、后继节点的度只可能是1 和0\n*删除实现*\n```\n    //删除\n	private void remove(Node<E> node) {\n		//节点为null\n		if(node ==null) return ;\n		size--;\n		//节点度为2\n		if(node.hasTwoChildren()) {\n			// 找到后继节点或者前驱节点\n			Node<E> s=successor(node);\n			// 用后继节点的值覆盖度为2的节点的值\n			node.element=s.element;\n			// 删除后继节点\n			node=s;\n		}\n		// 删除node节点（node的度必然是1或者0） 找到代替节点 左子树或者右子树\n		Node<E> replacement = node.left != null ? node.left : node.right;\n		if (replacement != null) { // node是度为1的节点\n			// 更改parent\n			replacement.parent=node.parent;\n			// 更改parent的left、right的指向\n			if (node.parent == null) { // node是度为1的节点并且是根节点\n				root=replacement;\n			}else if (node == node.parent.left) {//左节点\n				node.parent.left = replacement;\n			}else { // node == node.parent.right  父节点时右节点\n				node.parent.right = replacement;\n			}\n		} else if (node.parent == null) { // node是叶子节点并且是根节点\n			root = null;\n		} else { // node是叶子节点，但不是根节点\n			if (node == node.parent.left) {\n				node.parent.left = null;\n			} else { // node == node.parent.right\n				node.parent.right = null;\n			}\n		}\n	}\n```\n\n\n\n\n\n', '78', '5', '77', '0', '2', '0', '2020-06-29 14:35:03', '2020-06-29 14:35:03');
INSERT INTO `article` VALUES ('13', '数据结构--AVL树', '学习记录，本篇主要内容是二叉搜索树', '九曜', '\n\n#### ◼平衡二叉搜索树（Balanced Binary Search Tree）\n**●二叉搜索树的复杂度分析**\n添加、删除节点时，都可能会导致二叉搜索树退化成链表\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200304170238340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)**●平衡（Balance）**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200304170404812.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n**●如何改进二叉搜索树？**\n◼首先，节点的添加、删除顺序是无法限制的，可以认为是随机的\n◼所以，改进方案是：在节点的添加、删除操作之后，想办法让二叉搜索树恢复平衡（减小树的高度）\n◼如果接着继续调整节点的位置，完全可以达到理想平衡，但是付出的代价可能会比较大，比如调整的次数会比较多，反而增加了时间复杂度\n◼总结来说，比较合理的改进方案是：用尽量少的调整次数达到适度平衡即可\n◼一棵达到适度平衡的二叉搜索树，可以称之为：平衡二叉搜索树\n◼经典常见的平衡二叉搜索树有\n\n## AVL树\n\n✓WindowsNT 内核中广泛使用\n\n## 红黑树\n\nC++STL（比如map、set ）Java 的TreeMap、TreeSet、HashMap、HashSet  、Linux 的进程调度、 Ngix 的timer 管理\n●一般也称它们为：自平衡的二叉搜索（SelfbalancingBinarySearchTree）\n\n----\n## ◼AVL树\n◼平衡因子（Balance Factor）：某结点的左右子树的高度差\n◼AVL树的特点：每个节点的平衡因子只可能是1、0、-1（绝对值≤ 1，如果超过1，称之为“失衡”）\n●每个节点的左右子树高度差不超过1\n●搜索、添加、删除的时间复杂度是O(logn)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200304170935432.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)**接口简单设计**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200304171010220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n**◼添加导致的失衡**\n●添加：只要让高度最低的失衡节点恢复平衡，整棵树就恢复平衡【仅需O(1) 次调整】\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200304171146634.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\nprivate boolean isBalanced(Node<E> node) {\n		return Math.abs(((AVLNode<E>)node).balanceFactor()) <= 1;\n	}\nprotected void afterAdd(Node<E> node) {\n		while(node.parent!=null) {\n			if(isBalanced(node)) {\n				//更新高度\n				updateHeight(node);\n			}else {\n				//恢复平衡\n				rebalance(node);\n				// 整棵树恢复平衡\n				break;\n			}\n		}\n	}\n```\n\n**◼删除导致的失衡**\n●删除：恢复平衡后，可能会导致更高层的祖先节点失衡，最多需要O(logn) 次调整\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020030417123350.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\nprotected void afterRemove(Node<E> node) {\n		while(node.parent!=null) {\n			if(isBalanced(node)) {\n				//更新高度\n				updateHeight(node);\n			}else {\n				//恢复平衡\n				rebalance(node);\n			}\n		}\n	}\n```\n**●LL–右旋转（单旋）**\nLL情况：当前n节点是祖父节点的左子树的左子树时，就是左左。\n则右旋转使其平衡，\n具体为：祖父节点g指向父节点p的右子树，并父节点p成为这颗子树的根节点，祖父节点g成为父节点p的子树，更改的只有红线部分。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200304171529908.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\n private void rotateRight(Node<E> grand) {\n    	//交换子树\n    	Node<E> parent = grand.left;\n		Node<E> child = parent.right;\n		grand.left = child;\n		parent.right = grand;\n		//维护parent和hegiht\n		afterRotate(grand, parent, child);\n		}\n```\n\n**●RR –左旋转（单旋）**\nRR情况：当前n节点是祖父节点的右子树的右子树时，就是右右。\n则左旋转使其平衡。\n具体为：祖父节点g指向父节点p的左子树，并父节点p成为这颗子树的根节点，祖父节点g成为父节点p的子树，更改的只有红线部分。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020030417160491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\nprivate void rotateLeft(Node<E> grand) {\n		//交换子树\n		Node<E> parent = grand.right;\n		Node<E> child = parent.left;\n		grand.right=child;\n		parent.left=grand;\n		//维护parent和hegiht\n		afterRotate(grand, parent, child);\n	}\n	private void afterRotate(Node<E> grand, Node<E> parent, Node<E> child) {\n		// 让parent称为子树的根节点\n		parent.parent=grand.parent;\n		if(grand.isLeftChild()) {\n			grand.parent.left=parent;\n		}else if (grand.isRightChild()) {\n			grand.parent.right = parent;\n		} else { // grand是root节点\n			root = parent;\n		}\n		// 更新child的parent\n		if (child != null) {\n			child.parent = grand;\n		}\n		// 更新grand的parent\n			grand.parent = parent;\n		// 更新高度\n			updateHeight(grand);\n			updateHeight(parent);\n	}\n```\n**●LR –RR左旋转，LL右旋转（双旋）**\n父节点P先左旋转，然后祖父节点G右旋转\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200304171634922.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)**●RL –LL右旋转，RR左旋转（双旋）**\n父节点p先右旋转，然后祖父节点g左旋转\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200304171808960.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\nprivate void rebalance(Node<E> grand) {\n		Node<E> parent = ((AVLNode<E>)grand).tallerChild();\n		Node<E> node = ((AVLNode<E>)parent).tallerChild();\n		if(parent.isLeftChild()) {//L\n			if(node.isLeftChild()) {//LL\n				rotateRight(grand);\n			}else {//LR\n				rotateRight(parent);\n				rotateLeft(grand);\n			}\n		}else {//R\n			if(node.isLeftChild()) {//RL\n				rotateRight(parent);\n				rotateLeft(grand);\n			}else {//RR\n				rotateLeft(grand);\n			}\n		}\n	}\n```\n◼独立出AVLNode![在这里插入图片描述](https://img-blog.csdnimg.cn/20200304173755435.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\nprivate static class AVLNode<E> extends Node<E> {\n        int height = 1;\n		public AVLNode(E element, Node<E> parent) {\n			super(element, parent);\n			// TODO Auto-generated constructor stub\n		}\n		//平衡因子\n		public int balanceFactor() {\n			int leftheight = left ==null ? 0:((AVLNode<E>)left).height;\n			int rightheight = left ==null ? 0:((AVLNode<E>)right).height;\n			return leftheight-rightheight;\n		}\n		//更新高度\n		public void updateHeight() {\n			int leftheight = left ==null ? 0:((AVLNode<E>)left).height;\n			int rightheight = left ==null ? 0:((AVLNode<E>)right).height;\n			height=1+Math.max(leftheight, rightheight);\n		}\n		//判断左右子树\n		public Node<E> tallerChild() {\n			int leftheight = left ==null ? 0:((AVLNode<E>)left).height;\n			int rightheight = left ==null ? 0:((AVLNode<E>)right).height;\n			if (leftheight > rightheight) return left;\n			if (leftheight < rightheight) return right;\n			return  isLeftChild()  ? left : right;\n		}\n        @Override\n		public String toString() {\n			String parentString = \"null\";\n			if (parent != null) {\n				parentString = parent.element.toString();\n			}\n			return element + \"_p(\" + parentString + \")_h(\" + height + \")\";\n		}\n		\n	}\n```\n\n◼平均时间复杂度：搜索：O(logn)、添加：O(logn)，仅需O(1) 次的旋转操作，删除：O(logn)，最多需要O(logn) 次的旋转操作。\n\n\n\n\n\n\n\n\n\n', '48', '6', '44', '1', '13', '0', '2020-06-29 14:36:32', '2020-06-29 14:36:32');
INSERT INTO `article` VALUES ('14', '数据结构--B树、B+树的概念', '学习记录，本篇主要内容是B树基本概念', '九曜', '\n\n#### ◼B树（B-tree、B-树）\n\n●B树是一种平衡的多路搜索树，多用于文件系统、数据库的实现（数据库所用的树一般为200-300阶B树）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307141118232.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n● 1个节点可以存储超过2 个元素、可以拥有超过2 个子节点\n●拥有二叉搜索树的一些性质：平衡，每个节点的所有子树高度一致，比较矮、高度低。\n\n**◼m阶B树的性质（m≥2）**\n●假设一个节点存储的元素个数为x\n●根节点：1≤x≤m − 1\n●非根节点：┌ m/2 ┐ − 1≤x ≤m − 1 \n（ ┌ m/2 ┐是向上取整,即取与结果最接近的比结果大的整数)\n●如果有子节点，子节点个数y =x + 1\n✓根节点：2≤y ≤m \n✓非根节点：┌ m/2 ┐≤y ≤m \n➢比如m = 3，2≤y≤3，因此可以称为（2, 3）树、2-3树\n➢比如m = 4，2≤y≤4，因此可以称为（2, 4）树、2-3-4树\n➢比如m = 5，3≤y≤5，因此可以称为（3, 5）树\n➢比如m = 6，3≤y≤6，因此可以称为（3, 6）树\n➢比如m = 7，4≤y≤7，因此可以称为（4, 7）树\n\n**◼B树VS二叉搜索树**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307141623208.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)●B树和二叉搜索树，在逻辑上是等价的\n➢多代节点合并，可以获得一个超级节点\n➢2代合并的超级节点，最多拥有4 个子节点（至少是4阶B树）\n➢3代合并的超级节点，最多拥有8 个子节点（至少是8阶B树）\n➢n代合并的超级节点，最多拥有2n个子节点（至少是2n阶B树）\n●m阶B树，最多需要log2m代合并\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307141635853.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n**◼添加**\n◼新添加的元素必定是添加到叶子节点\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307142333783.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)最右下角的叶子节点的元素个数将超过限制，这种现象可以称之为：**上溢（overflow）**\n添加–上溢的解决(假设5阶)\n◼上溢节点的元素个数必然等于m\n◼假设上溢节点最中间元素的位置为k，将k 位置的元素向上与父节点合并\n◼将[0, k-1] 和[k + 1, m -1] 位置的元素分裂成2 个子节点\n✓这2 个子节点的元素个数，必然都不会低于最低限制（┌ m/2 ┐ − 1）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307142720299.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n◼一次分裂完毕后，有可能导致父节点上溢，依然按照上述方法解决最极端的情况，有可能一直分裂到根节点\n\n#### ◼删除\n**◼删除–叶子节点**\n●假如需要删除的元素在叶子节点中，那么直接删除即可\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307142853268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)◼删除–非叶子节点\n●假如需要删除的元素在非叶子节点中\n1.先找到前驱或后继元素，覆盖所需删除元素的值\n2.再把前驱或后继元素删除\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307143048636.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n●非叶子节点的前驱或后继元素，必定在叶子节点中，所以这里的删除前驱或后继元素，就是最开始提到的情况：删除的元素在叶子节点中\n\n◼真正的删除元素都是发生在叶子节点中\n\n但叶子节点被删掉一个元素后，元素个数可能会低于最低限制（≥┌ m/2 ┐ − 1），这种现象称为：**下溢（underflow）**\n**删除–下溢的解决**\n●下溢节点的元素数量必然等于┌ m/2 ┐ − 2\n\n●如果下溢节点临近的兄弟节点，有至少┌ m/2 ┐ 个元素，可以向其借一个元素，将父节点的元素b 插入到下溢节点的0位置（最小位置），用兄弟节点的元素a（最大的元素）替代父节点的元素b，这种操作其实就是：旋转\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307143534807.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n●如果下溢节点临近的兄弟节点，只有┌ m/2 ┐− 1个元素，将父节点的元素b 挪下来跟左右子节点进行合并，合并后的节点元素个数等于┌ m/2 ┐ + ┌ m/2 ┐ − 2，不超过m − 1，这个操作可能会导致父节点下溢，依然按照上述方法解决，下溢现象可能会一直往上传播\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020030714363874.png)例如：![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307143653864.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n◼4阶B树\n●如果先学习4阶B树（2-3-4树），将能更好地学习理解红黑树\n●4阶B树的性质：\n➢所有节点能存储的元素个数x ：1≤x≤3\n➢所有非叶子节点的子节点个数y ：2≤y ≤4\n![◼添加从1 添加到22◼删除从1 删除到22小码哥教育@M了个J 小码哥教育@M了个J 小码哥教育@M了个J 小码](https://img-blog.csdnimg.cn/20200307143815388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n\n### B+树\n\nB+树是B树的变体，常用于数据库和操作系统的文件系统中，MySQL数据库的索引就是基于B+树实现的\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200411153541766.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\nB+树的特点：分为内部节点（非叶子）、叶子节点2种节点\n✓内部节点只存储key，不存储具体数据\n✓叶子节点存储key和具体数据\n\n所有的叶子节点形成一条有序链表\n\nm阶B+树非根节点的元素数量x\n✓┌ m/2 ┐≤x ≤m\n\n**操作系统读取硬盘数据的过程**\n①操作系统将LBA传送给磁盘驱动器并启动读取命令\n✓LBA（Logical Block Address，逻辑块地址）\n✓比如类似设备号4、磁头号4、磁道号8、扇区号16、扇区计数8这样的信息\n②磁盘驱动器根据LBA将磁头移动到正确的磁道，盘片开始旋转，将目标扇区旋转到磁头下\n③磁盘控制器将扇区数据等信息传送到一个处于磁盘界面的缓冲区\n④磁盘驱动器向操作系统发出“数据就绪”信号\n⑤操作系统从磁盘界面的缓冲区读取数据✓既可以按照一个字节一个字节的方式读取\n✓也可以启动DMA（Direct Memory Access，直接内存访问）命令读取\n\n**磁盘完成IO操作的时间**\n主要由寻道时间、旋转延迟时间、数据传输时间3部分构成\n寻道时间（seek）\n✓将读写磁头移动至正确的磁道上所需要的时间，这部分时间代价最高\n旋转延迟时间（rotation）\n✓盘片旋转将目标扇区移动到读写磁头下方所需要的时间，取决于磁盘转速\n数据传输时间（transfer）\n✓完成传输数据所需要的时间，取决于接口的数据传输率，通常远小于前两部分消耗时间\n\n决定时间长短的大部分因素是和硬件相关的，但所需移动的磁道数是可以通过操作系统来进行控制的\n减少所需移动的磁道数是减少整个硬盘读写时间的有效办法\n合理安排磁头的移动以减少寻道时间就是磁盘调度算法的目的所在\n\n**MySQL的索引底层为何使用B+树？**\n为了减小IO操作数量，一般把一个节点的大小设计成最小读写单位的大小\nMySQL的存储引擎InnoDB的最小读写单位是16K\n\n**对比B树，B+树的优势是**\n每个节点存储的key数量更多，树的高度更低\n所有的具体数据都存在叶子节点上，所以每次查询都要查到叶子节点，查询速度比较稳定\n所有的叶子节点构成了一个有序链表，做区间查询时更方便\n\n### B*树\nB*树是B+树的变体：给内部节点增加了指向兄弟节点的指针\nm阶B*树非根节点的元素数量x\n✓┌ 2m/3 ┐≤x ≤m\n![在这里插入图片描述](https://img-blog.csdnimg.cn/2020041115411629.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n\n\n\n', '49', '7', '44', '0', '3', '0', '2020-06-29 14:37:25', '2020-06-29 14:37:25');
INSERT INTO `article` VALUES ('15', '数据结构--红黑树', '学习记录，本篇主要内容是红黑树', '九曜', '\n\n### ◼红黑树（RedBlackTree）\n\n◼红黑树也是一种自平衡的二叉搜索树，以前也叫做平衡二叉B树（Symmetric Binary B-tree）\n◼红黑树必须满足以下5 条性质\n1.节点是RED 或者BLACK\n2.根节点是BLACK\n3.叶子节点（外部节点，空节点null）都是BLACK（虚拟出的节点）\n4.RED 节点的子节点都是BLACK\n✓RED 节点的parent 都是BLACK\n✓从根节点到叶子节点的所有路径上不能有2 个连续的RED 节点\n5.从任一节点到叶子节点的所有路径都包含相同数目的BLACK 节点\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307144605771.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)**◼红黑树的等价变换**\n●红黑树和4阶B树（2-3-4树）具有等价性（下图省略了NULL 节点）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307144833617.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)●BLACK 节点与它的RED子节点融合在一起，形成1个B树节点\n●红黑树的BLACK 节点个数与4阶B树的节点总个数相等\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307144822821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n\n**◼添加**\n已知：B树中，**新元素必定是添加到叶子节点中**，4阶B树所有节点的元素个数x 都符合1 ≤  x≤ 3\n●新添加的节点默认为RED，这样能够让红黑树的性质尽快满足（性质1、2、3、5 都满足，性质4 不一定）\n\n◼如果添加的是根节点，染成BLACK 即可\n\n◼有4 种情况满足红黑树的性质4 ：parent 为BLACK\n同样也满足4阶B树的性质，因此不用做任何额外处理\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307145351355.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n◼有8 种情况不满足红黑树的性质4 ：parent 为RED（DoubleRed ）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307145536106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)其中前4 种属于B树节点上溢的情况\n**添加–修复性质4 –上溢**\n◼判定条件：uncle （叔父节点，parent的兄弟节点）是RED\n1.parent（父节点）、uncle 染成BLACK\n2.grand（祖父节点） 向上合并，染成RED，当做是新添加的节点进行处理\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307145928788.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n◼grand 向上合并时，可能继续发生上溢，若上溢持续到根节点，只需将根节点染成BLACK。\n\n其中后4 种情况\n**添加–修复性质4 –LL\\RR**\n◼判定条件：uncle 不是RED\n1.parent 染成BLACK，grand 染成RED\n2.grand 进行单旋操作\n●LL：右旋转\n●RR：左旋转\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307150139784.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)**添加–修复性质4 –LR\\RL**\n◼判定条件：uncle 不是RED\n1.自己染成BLACK，grand 染成RED\n2.进行双旋操作\n●LR：parent 左旋转，grand 右旋转\n●RL：parent 右旋转，grand 左旋转\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307150306883.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\nprotected void afterAdd(Node<E> node) {\n		Node<E> parent = node.parent;\n		// 添加的是根节点 或者 上溢到达了根节点\n		if (parent == null) {\n			black(node);\n			return;\n		}\n		// 如果父节点是黑色，直接返回\n		if (isBlack(parent)) return;\n		// 叔父节点\n		Node<E> uncle = parent.sibling();\n		// 祖父节点\n		Node<E> grand = red(parent.parent);\n		if (isRed(uncle)) { // 叔父节点是红色【B树节点上溢】\n			black(parent);\n			black(uncle);\n			// 把祖父节点当做是新添加的节点\n			afterAdd(grand);\n			return;\n		}\n		// 叔父节点不是红色\n		if (parent.isLeftChild()) { // L\n			if (node.isLeftChild()) { // LL\n				black(parent);\n			} else { // LR\n				black(node);\n				rotateLeft(parent);\n			}\n			rotateRight(grand);\n		} else { // R\n			if (node.isLeftChild()) { // RL\n				black(node);\n				rotateRight(parent);\n			} else { // RR\n				black(parent);\n			}\n			rotateLeft(grand);\n		}\n	}\n```\n\n#### ◼删除：\n\n**B树中，最后真正被删除的元素都在叶子节点中**\n\n**删除–RED节点**：直接删除，不用作任何调整\n**删除–BLACK节点：**\n●拥有2 个RED 子节点的BLACK 节点\n✓不可能被直接删除，因为会找它的子节点替代删除\n✓因此不用考虑这种情况\n\n●拥有1 个RED 子节点的BLACK 节点\n\n●BLACK 叶子节点\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307150617251.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)**◼删除–拥有1个RED子节点的BLACK节点**\n●判定条件：用以替代的子节点是RED\n●将替代的子节点染成BLACK 即可保持红黑树性质\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307150812399.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n**删除–BLACK叶子节点–sibling（兄弟节点）为BLACK**\n◼BLACK 叶子节点被删除后，会导致B树节点下溢（比如删除88）\n◼**如果sibling 至少有1 个RED 子节点**，进行旋转操作，旋转之后的中心节点继承parent 的颜色，旋转之后的左右节点染为BLACK（和兄弟节点借一位节点）![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307151404779.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)**若兄弟节点没有节点可以借。**\n◼判定条件：sibling 没有1 个RED 子节点\n●将sibling 染成RED、parent 染成BLACK 即可修复红黑树性质\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307151612868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n◼如果parent 是BLACK，会导致parent 也下溢，这时只需要把parent 当做被删除的节点处理即可\n\n**删除–BLACK叶子节点–sibling为RED**\n◼如果sibling 是RED，sibling 染成BLACK，parent 染成RED，进行旋转，于是又回到sibling 是BLACK 的情况\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307151915839.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n\n```\nprotected void afterRemove(Node<E> node) {\n		// 如果删除的节点是红色\n		// 或者 用以取代删除节点的子节点是红色\n		if (isRed(node)) {\n			black(node);\n			return;\n		}\n		Node<E> parent = node.parent;\n		// 删除的是根节点\n		if (parent == null) return;\n		// 删除的是黑色叶子节点【下溢】\n		// 判断被删除的node是左还是右\n		boolean left = parent.left == null || node.isLeftChild();\n		Node<E> sibling = left ? parent.right : parent.left;\n		if (left) { // 被删除的节点在左边，兄弟节点在右边\n			if (isRed(sibling)) { // 兄弟节点是红色\n				black(sibling);\n				red(parent);\n				rotateLeft(parent);\n				// 更换兄弟\n				sibling = parent.right;\n			}\n			// 兄弟节点必然是黑色\n			if (isBlack(sibling.left) && isBlack(sibling.right)) {\n				// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并\n				boolean parentBlack = isBlack(parent);\n				black(parent);\n				red(sibling);\n				if (parentBlack) {\n					afterRemove(parent);\n				}\n			} else { // 兄弟节点至少有1个红色子节点，向兄弟节点借元素\n				// 兄弟节点的左边是黑色，兄弟要先旋转\n				if (isBlack(sibling.right)) {\n					rotateRight(sibling);\n					sibling = parent.right;\n				}\n				color(sibling, colorOf(parent));\n				black(sibling.right);\n				black(parent);\n				rotateLeft(parent);\n			}\n		} else { // 被删除的节点在右边，兄弟节点在左边\n			if (isRed(sibling)) { // 兄弟节点是红色\n				black(sibling);\n				red(parent);\n				rotateRight(parent);\n				// 更换兄弟\n				sibling = parent.left;\n			}\n			// 兄弟节点必然是黑色\n			if (isBlack(sibling.left) && isBlack(sibling.right)) {\n				// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并\n				boolean parentBlack = isBlack(parent);\n				black(parent);\n				red(sibling);\n				if (parentBlack) {\n					afterRemove(parent);\n				}\n			} else { // 兄弟节点至少有1个红色子节点，向兄弟节点借元素\n				// 兄弟节点的左边是黑色，兄弟要先旋转\n				if (isBlack(sibling.left)) {\n					rotateLeft(sibling);\n					sibling = parent.left;\n				}\n				color(sibling, colorOf(parent));\n				black(sibling.left);\n				black(parent);\n				rotateRight(parent);\n			}\n		}\n	}\n	//辅助方法\n	//染色方法\n	private Node<E> color(Node<E> node, boolean color) {\n		if (node == null) return node;\n		((RBNode<E>)node).color = color;\n		return node;\n	}\n	//染红色\n	private Node<E> red(Node<E> node) {\n		return color(node, RED);\n	}\n	//染黑色\n	private Node<E> black(Node<E> node) {\n		return color(node, BLACK);\n	}\n	//判断颜色\n	private boolean colorOf(Node<E> node) {\n		return node == null ? BLACK : ((RBNode<E>)node).color;\n	}\n	//判断是否是黑色节点\n	private boolean isBlack(Node<E> node) {\n		return colorOf(node) == BLACK;\n	}\n	//判断是否是红色节点\n	private boolean isRed(Node<E> node) {\n		return colorOf(node) == RED;\n	}\n	//创建节点方法\n	protected Node<E> createNode(E element, Node<E> parent) {\n		return new RBNode<>(element, parent);\n	}\n	//红黑树节点类\n	private static class RBNode<E> extends Node<E> {\n		boolean color = RED;\n		public RBNode(E element, Node<E> parent) {\n			super(element, parent);\n		}\n		@Override\n		public String toString() {\n			String str = \"\";\n			if (color == RED) {\n				str = \"R_\";\n			}\n			return str + element.toString();\n		}\n	}\n```\n红黑树的实现关键是添加删除后节点的颜色一定要符合红黑树的性质\n### 红黑树的平衡\n最初遗留的困惑：为何那5条性质，就能保证红黑树是平衡的？\n◼因为那5条性质，可以保证红黑树等价于4阶B树\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200307152006192.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n相比AVL树，红黑树的平衡标准比较宽松：\n●没有一条路径会大于其他路径的2倍\n●是一种弱平衡、黑高度平衡\n●红黑树的最大高度是2∗log2(n+1)，依然是O(logn) 级别\n\n**AVL树vs 红黑树**\n◼AVL树：\n平衡标准比较严格：每个左右子树的高度差不超过1\n最大高度是1.44∗log2n+2−1.328（100W个节点，AVL树最大树高28）\n搜索、添加、删除都是O(logn) 复杂度，其中添加仅需O(1) 次旋转调整、删除最多需要O(logn) 次旋转调整\n\n◼红黑树：\n平衡标准比较宽松：没有一条路径会大于其他路径的2倍\n最大高度是2∗log2(n+1)（100W个节点，红黑树最大树高40）\n搜索、添加、删除都是O(logn) 复杂度，其中添加、删除都仅需O(1) 次旋转调整\n\n**搜索的次数远远大于插入和删除，选择AVL树；\n搜索、插入、删除次数几乎差不多，选择红黑树**\n\n相对于AVL树来说，红黑树牺牲了部分平衡性以换取插入/删除操作时少量的旋转操作，整体来说性能要优于AVL树\n**红黑树的平均统计性能优于AVL树，实际应用中更多选择使用红黑树**\n\n\n\n\n\n\n', '32', '8', '33', '0', '1', '0', '2020-06-29 14:38:15', '2020-06-29 14:38:15');
INSERT INTO `article` VALUES ('16', '数据结构--集合与映射', '学习记录，本篇主要内容是集合与映射', '九曜', '\n\n#### ◼集合（Set）\n\n**●集合的特点**\n●不存放重复的元素\n●常用于去重\n✓存放新增IP，统计新增IP 量\n✓存放词汇，统计词汇量\n思考：集合的内部实现能否直接利用以前学过的数据结构？\n动态数组、链表、二叉搜索树（AVL树、红黑树）。\n\n**集合的接口设计**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312103531713.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n***●链表实现set***\n```\npublic class ListSet<E> implements Set<E> {\n	private List<E> list = new LinkedList<>();\n	//数量\n	public int size() {\n		return list.size();\n	}\n	public boolean isEmpty() {\n		return list.isEmpty();\n	}\n	public void clear() {\n		list.clear();\n	}\n	public boolean contains(E element) {\n		return list.contains(element);\n	}\n	//去重\n	public void add(E element) {\n		int index=list.indexOf(element);\n		if(index != list.ELEMENT_NOT_FOUND) {//存在就覆盖 去重\n			list.set(index, element);\n		}else {\n			list.add(element);\n		}\n	}\n	public void remove(E element) {\n		int index=list.indexOf(element);\n		if (index != List.ELEMENT_NOT_FOUND) {//如果存在就删除\n			list.remove(index);\n		}\n	}\n	public void traversal(Visitor<E> visitor) {\n		if(visitor==null) return;\n		int size = list.size();\n		for(int i = 0 ; i<size;i++) {\n			if (visitor.visit(list.get(i))) return;\n		}\n	}\n}\n```\n***●红黑树实现treeSet***\n```\npublic class TreeSet<E> implements Set<E>{\n	private RBTree<E> tree;\n	public TreeSet() {\n		this(null);\n	}\n	//因为红黑树的元素需要可比较性\n	public TreeSet(Comparator<E>Comparator){\n		tree = new RBTree<>();\n	}\n	public int size() {\n		return tree.size();\n	}\n	public boolean isEmpty() {\n		return tree.isEmpty();\n	}\n	public void clear() {\n		tree.clear();\n	}\n	public boolean contains(E element) {\n		return tree.contains(element);\n	}\n	@Override\n	public void add(E element) {\n		tree.add(element);\n	}\n	@Override\n	public void remove(E element) {\n		tree.remove(element);\n	}\n	@Override\n	public void traversal(Visitor<E> visitor) {\n		tree.inorder(new BinaryTree.Visitor<E>() {\n			@Override\n			public boolean visit(E element) {\n				return visitor.visit(element);\n			}\n		});\n	}\n\n```\n\n#### ◼映射（Map）\n●Map 在有些编程语言中也叫做字典（dictionary，比如Python、Objective-C、Swift 等）\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200310152139545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)Map 将键映射到值的对象，键值对。\n◼Map 的每一个key 是唯一的\n\n**Map的接口设计**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312103506506.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n类似Set，Map 可以直接利用之前学习的链表、二叉搜索树（AVL树、红黑树）等数据结构来实现\n***红黑树实现treeMap***\n<K,V>，键的数据结构是红黑树,可保证键的排序和唯一性。\n需加上之前红黑树的旋转辅助等。`\n\n```\npublic class TreeMap<K,V> implements Map<K, V> {\n	private static final boolean RED = false;\n	private static final boolean BLACK = true;\n	private int size;//数量\n	private Node<K,V> root;//根节点\n	private Comparator<K> comparator;//比较器\n	public TreeMap() {//红黑树的元素要有可比较性\n		this(null);\n	}\n	public TreeMap(Comparator<K> comparator) {\n		this.comparator = comparator;\n	}\n	public int size() {//数量\n		return size;\n	}\n	public boolean isEmpty() {\n		return size==0;\n	}\n	public void clear() {\n		size=0;\n		root=null;\n	}\n	public V put(K key, V value) {//添加\n		//判断key是否为空，空抛出异常\n		keyNotNullCheck(key);\n		//添加的第一个节点\n		if(root==null) {\n			root = new Node<>(key, value, null); \n			size++;\n			// 新添加节点之后的处理\n			afterPut(root);\n			return null;\n		}\n		// 添加的不是第一个节点\n		// 找到父节点\n		Node<K, V> parent = root;\n		Node<K, V> node = root;\n		int cmp=0;\n		do {\n			cmp = compare(key, node.key);\n			parent = node;\n			if(cmp>0) {\n				node=node.right;\n			}else if(cmp<0) {\n				node=node.left;\n			}else {//相等\n				node.key=key;\n				V oldValue=node.value;\n				node.value=value;\n				return oldValue;\n			}\n		}while(node!=null);\n		// 看看插入到父节点的哪个位置\n		Node<K, V> newNode = new Node<>(key, value, parent);\n		if(cmp>0) {\n			parent.right = newNode;\n		}else {\n			parent.left = newNode;\n		}\n		// 新添加节点之后的处理\n		afterPut(newNode);//红黑树的方法\n		return null;\n	}\n	public V get(K key) {/得到元素\n		Node<K, V> node = node(key);\n		return node!=null?node.value:null;\n	}\n	public V remove(K key) {//删除\n		return remove(node(key));//红黑树的方法\n	}\n	public boolean containsKey(K key) {//是否存在某元素\n		return node(key)!=null;\n	}\n	public boolean containsValue(V value) {//是否存在某值\n		if(root ==null) return false;\n		Queue<Node<K, V>> queue = new LinkedList<>();\n		queue.offer(root);\n		while(!queue.isEmpty()) {\n			Node<K, V> node = queue.poll();\n			if(valEquals(value, node.value)) return true;\n			if (node.left!=null) {\n				queue.offer(node.left);\n			}\n			if (node.right!=null) {\n				queue.offer(node.right);\n			}\n		}\n		return false;\n	}\n	@Override\n	public void traversal(Visitor<K, V> visitor) {//遍历外部接口\n		if (visitor==null) return;\n		traversal(root,visitor);\n	}\n	private void traversal(Node<K, V> node, Visitor<K, V> visitor) {//遍历实现\n		if (node==null || visitor==null) return;\n		traversal(node.left,visitor);\n		if (visitor.stop) return;\n		visitor.visit(node.key, node.value);\n		traversal(node.right, visitor);\n	}\n	private boolean valEquals(V v1,V v2) {//判断两值是否相等\n		return v1==null?v2 ==null:v1.equals(v2);\n	}\n	private V remove(Node<K, V> node) {//删除实现\n		if (node == null) return null;\n		size--;\n		V oldValue = node.value;\n		if (node.hasTwoChildren()) { // 度为2的节点\n			// 找到后继节点\n			Node<K, V> s = successor(node);\n			// 用后继节点的值覆盖度为2的节点的值\n			node.key = s.key;\n			node.value = s.value;\n			// 删除后继节点\n			node = s;\n		}\n		// 删除node节点（node的度必然是1或者0）\n		Node<K, V> replacement = node.left != null ? node.left : node.right;\n		if (replacement != null) { // node是度为1的节点\n			// 更改parent\n			replacement.parent = node.parent;\n			// 更改parent的left、right的指向\n			if (node.parent == null) { // node是度为1的节点并且是根节点\n				root = replacement;\n			} else if (node == node.parent.left) {\n				node.parent.left = replacement;\n			} else { // node == node.parent.right\n				node.parent.right = replacement;\n			}\n			// 删除节点之后的处理\n			afterRemove(replacement);\n		} else if (node.parent == null) { // node是叶子节点并且是根节点\n			root = null;\n		} else { // node是叶子节点，但不是根节点\n			if (node == node.parent.left) {\n				node.parent.left = null;\n			} else { // node == node.parent.right\n				node.parent.right = null;\n			}\n			// 删除节点之后的处理\n			afterRemove(node);//红黑树的方法\n		}\n		return oldValue;\n	}\n	private Node<K, V> node(K key) {//得到node节点方法\n		Node<K, V> node = root;\n		while (node != null) {\n			int cmp = compare(key, node.key);\n			if (cmp == 0) return node;\n			if (cmp > 0) {\n				node = node.right;\n			} else { // cmp < 0\n				node = node.left;\n			}\n		}\n		return null;\n	}\n	private int compare(K e1, K e2) {//比较器实现\n		if (comparator != null) {\n			return comparator.compare(e1, e2);\n		}\n		return ((Comparable<K>)e1).compareTo(e2);\n	}\n	private void keyNotNullCheck(K key) {//检查key是否为空\n		if (key == null) {//不允许key为空\n			throw new IllegalArgumentException(\"key must not be null\");\n		}\n	}\n	private static class Node<K,V> {//node节点类\n		K key;\n		V value;\n		boolean color = RED;\n		Node<K,V> left;\n		Node<K,V> right;\n		Node<K,V> parent;\n		public Node(K key, V value, Node<K, V> parent) {\n			this.key = key;\n			this.value = value;\n			this.parent = parent;\n		}\n		//。。。红黑树辅助方法\n	}\n\n```\n\n***Map与Set***\n◼*Map 的所有key 组合在一起，其实就是一个Set*\n◼因此，Set 可以间接利用Map 来作内部实现\n```\npublic class MapTreeSet<E> implements Set<E>{\n	Map<E,Object> map = new TreeMap<>();\n	public int size() {\n		return map.size();\n	}\n	public boolean isEmpty() {\n		return map.isEmpty();\n	}\n	public void clear() {\n		map.clear();	\n	}\n	public boolean contains(E element) {\n		return map.containsKey(element);\n	}\n	public void add(E element) {//关键点就是key存储element值，value为空\n		map.put(element, null);\n	}\n	public void remove(E element) {\n		map.remove(element);\n	}\n	public void traversal(Visitor<E> visitor) {\n		map.traversal(new Map.Visitor<E, Object>() {\n			@Override\n			public boolean visit(E key, Object value) {\n				return visitor.visit(key);\n			}\n		});\n	}\n}\n```\n\n', '89', '9', '88', '1', '2', '0', '2020-06-29 14:39:06', '2020-06-29 14:39:06');
INSERT INTO `article` VALUES ('17', '数据结构--哈希表', '学习记录，主要内容是哈希表', '九曜', '\n\n#### ◼哈希表（Hash Table）\n\n由于TreeMap特点：●Key 必须具备可比较性●元素的分布是有顺序的\n\n在实际应用中，很多时候的需求，Map 中存储的元素不需要讲究顺序，Map 中的Key 不需要具备可比较性，不考虑顺序、不考虑Key 的可比较性，Map 有更好的实现方案，平均时间复杂度可以达到O(1)，那就是采取哈希表来实现Map。\n\n◼**哈希表也叫做散列表（hash 有“剁碎”的意思）**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312155351609.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n添加、搜索、删除的流程都是类似的：\n1.利用哈希函数生成key 对应的index【O(1)】\n2.根据index 操作定位数组元素【O(1)】\n●哈希表是【空间换时间】的典型应用●哈希函数，也叫做散列函数\n●哈希表内部的数组元素，很多地方也叫Bucket（桶），整个数组叫Buckets 或者Bucket Array\n\n**◼哈希冲突（Hash Collision）**\n哈希冲突也叫做哈希碰撞：2 个不同的key，经过哈希函数计算出相同的结果，key1 ≠ key2 ，hash(key1) =hash(key2)\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312155653545.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n**◼解决哈希冲突的常见方法**\n1.开放定址法（Open Addressing），按照一定规则向其他地址探测，直到遇到空桶\n2.再哈希法（Re-Hashing），设计多个哈希函数\n3.链地址法（Separate Chaining），比如通过链表将同一index的元素串起来\n\n**◼JDK1.8的哈希冲突解决方案**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312155802410.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n●默认使用单向链表将元素串起来\n●在添加元素时，可能会由单向链表转为红黑树来存储元素，比如当哈希表容量≥ 64 且单向链表的节点数量大于8 时\n●当红黑树节点数量少到一定程度时，又会转为单向链表\n◼JDK1.8中的哈希表是使用链表+红黑树解决哈希冲突，这里为什么使用单链表？因为每次都是从头节点开始遍历，而单向链表比双向链表少一个指针，可以节省内存空间\n\n**◼哈希函数**：\n●良好的哈希函数，会让哈希值更加均匀分布→减少哈希冲突次数→提升哈希表的性能\n●哈希表中哈希函数的实现步骤大概如下\n1.先生成key 的哈希值（必须是整数并且可以进一步处理，扰动计算）\n2.再让key 的哈希值跟数组的大小进行相关运算，生成一个索引值\n●为了提高效率，可以使用& 位运算取代% 运算【前提：将数组的长度设计为2 的幂（2n）】\n```\nprivate int hash(K key) {//哈希值\n		if(key==null) return 0;\n		int hash = key.hashCode(); //该hashCode方法为JDK计算哈希值的方法\n		return hash ^ (hash >>> 16);//扰动计算：hash ^ (hash >>> 16)\n	}\n	private int index(K key) {//索引值\n		return hash(key) & (table.length-1);\n	}\n```\n**◼如何生成key的哈希值**\n●key 的常见种类可能有：整数、浮点数、字符串、自定义对象，不同种类的key，哈希值的生成方式不一样，但目标是一致的\n✓尽量让每个key 的哈希值是唯一的✓尽量让key 的所有信息参与运算\n●在Java中，HashMap 的key 必须实现hashCode、equals 方法，也允许key 为null\n◼整数\n整数值当做哈希值：比如10 的哈希值就是10\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312160912506.png)\n◼浮点数\n将存储的二进制格式转为整数值\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312160934894.png)◼Long和Double的哈希值\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312161034383.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n●>>> 和^ 的作用是？\n高32bit 和低32bit 混合计算出32bit 的哈希值，充分利用所有信息计算出哈希值\n\n◼字符串的哈希值\n●字符串是由若干个字符组成的：比如字符串jack，由j、a、c、k 四个字符组成（字符的本质就是一个整数），因此，jack 的哈希值可以表示为j∗n3+a∗n2+c∗n1+k∗n0，等价于[(j∗n+a)∗n+c]∗n+k\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312161213758.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n◼关于31的探讨\n●31 * i=  (2^5 –1) * i=  i * 2^5 –i =  (i << 5) –i\n●31不仅仅是符合2^n –1，它是个奇素数（既是奇数，又是素数，也就是质数）\n素数和其他数相乘的结果比其他方式更容易产成唯一性，减少哈希冲突，最终选择31是经过观测分布结果后的选择\n\n◼自定义对象的哈希值\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312161658605.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n**◼自定义对象作为key，最好同时重写hashCode 、equals 方法**\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200312161707848.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n●equals ：用以判断2 个key 是否为同一个key\n✓自反性：对于任何非null 的x，x.equals(x)必须返回true\n✓对称性：对于任何非null 的x、y，如果y.equals(x) 返回true，x.equals(y) 必须返回true\n✓传递性：对于任何非null 的x、y、z，如果x.equals(y)、y.equals(z) 返回true，那么x.equals(z) 必须返回true\n✓一致性：对于任何非null 的x、y，只要equals 的比较操作在对象中所用的信息没有被修改，多次调用x.equals(y) 就会一致地返回true，或者一致地返回false\n✓对于任何非null 的x，x.equals(null) 必须返回false。\n\n●hashCode ：必须保证equals 为true的2 个key 的哈希值一样，\n反过来hashCode 相等的key，不一定equals 为true。\n●不重写hashCode 方法只重写equals 会有什么后果？\n✓可能会导致2 个equals 为true 的key 同时存在哈希表中\n\n**◼装填因子（Load Factor）：**\n●装填因子计算：节点总数量/ 哈希表桶数组长度，也叫做负载因子\n●在JDK1.8的HashMap中，如果装填因子超过0.75，就扩容为原来的2倍\n\n**◼TreeMapvs HashMap**\n●何时选择TreeMap？元素具备可比较性且要求升序遍历（按照元素从小到大）\n●何时选择HashMap？无序遍历\n\n**红黑树实现哈希表，不采用单向链表**\n```\npackage com.bj.map;\nimport java.util.LinkedList;\nimport java.util.Objects;\nimport java.util.Queue;\n@SuppressWarnings({\"unchecked\", \"rawtypes\"})\npublic class HashMap<K, V> implements Map<K, V> {\n	private static final boolean RED=false;\n	private static final boolean BLACK=true;\n	private int size;\n	private Node<K,V> [] table;\n	private static final int DEFAULT_CAPACITY=1<<4;//16\n	//装填因子\n	private static final float DEFAULT_LOAO_FACTOR=0.75f;\n	public HashMap() {\n		table=new Node[DEFAULT_CAPACITY];\n	}\n	public int size() {\n		return size;\n	}\n	public boolean isEmpty() {\n		return size == 0;\n	}\n	public void clear() {\n		if(size==0) return;\n		size=0;\n		for(int i = 0;i<table.length;i++) {\n			table[i] = null;//把存储索引的数组清空即可\n		}\n	}\n	public V put(K key, V value) {\n		resize();\n		int index = index(key);//索引位置\n		// 取出index位置的红黑树根节点\n		Node<K, V> root = table[index];\n		if(root ==null) {\n			root = new Node<>(key, value, null);\n			table[index] = root;\n			size++;\n			fixAfterPut(root);\n			return null;\n		}\n		// 添加新的节点到红黑树上面\n		Node<K, V> parent = root;\n		Node<K, V> node = root;\n		int cmp =0;\n		K k1 = key;\n		int h1 = k1==null?0:k1.hashCode();\n		Node<K, V> result= null;\n		boolean searched = false;// 是否已经搜索过这个key\n		do {\n			parent = node;//记录父节点\n			K k2 = node.key;\n			int h2 = k2.hashCode();\n			if (h1 > h2) {\n				cmp = 1;\n			} else if (h1 < h2) {\n				cmp = -1;\n			} else if (Objects.equals(k1, k2)) {\n				cmp = 0;\n			} else if (k1 != null && k2 != null \n					&& k1.getClass() == k2.getClass()\n					&& k1 instanceof Comparable\n					&& (cmp = ((Comparable) k1).compareTo(k2)) != 0) {\n			}else if(searched) { // 已经扫描了\n				cmp = System.identityHashCode(k1) - System.identityHashCode(k2);//内存地址计算大小\n			}else { // searched == false; 还没有扫描，然后再根据内存地址大小决定左右\n				if((node.left!=null &&(result = node(node.left,k1))!=null) ||\n						(node.right != null && (result = node(node.right, k1)) != null)) {\n					node=result;\n					cmp=0;\n				}else {//不存在这个key\n					searched = true;\n					cmp = System.identityHashCode(k1) - System.identityHashCode(k2);\n				}\n			}	\n			if(cmp>0) {\n				node=node.right;\n			}else if(cmp<0) {\n				node=node.left;\n			}else {//0 相等覆盖\n				V oldValue= node.value;//记录旧值\n				node.key=key;\n				node.value=value;\n				node.hash=h1;\n				return oldValue;\n			}\n		}while(node!=null);\n		// 看看插入到父节点的哪个位置\n		Node<K, V> newNode = new Node<>(key, value, parent);//创建新节点\n		if (cmp > 0) {\n			parent.right = newNode;\n		} else {\n			parent.left = newNode;\n		}\n		size++;\n		// 新添加节点之后的处理\n		fixAfterPut(newNode);\n		return null;\n	}\n	public V get(K key) {\n		Node<K, V> node = node(key);\n		return node!=null?node.value:null;\n	}\n	public V remove(K key) {\n		return remove(node(key));\n	}\n	public boolean containsKey(K key) {\n		return node(key) != null;\n	}\n	public boolean containsValue(V value) {\n		if(size==0) return false;\n		Queue<Node<K, V>> queue = new LinkedList<>();\n		for(int i = 0;i<table.length;i++) {\n			if(table[i] == null) continue;\n			queue.offer(table[i]);\n			while(!queue.isEmpty()) {\n				Node<K, V> node = queue.poll();\n				if(Objects.equals(value, node.value)) return true;\n				if (node.left != null) {\n					queue.offer(node.left);\n				}\n				if (node.right != null) {\n					queue.offer(node.right);\n				}\n			}\n		}\n		return false;\n	}\n	public void traversal(Visitor<K, V> visitor) {\n        if (size == 0 || visitor == null) return;\n		Queue<Node<K, V>> queue = new LinkedList<>();\n		for (int i = 0; i < table.length; i++) {\n			if (table[i] == null) continue;\n			queue.offer(table[i]);\n			while (!queue.isEmpty()) {\n				Node<K, V> node = queue.poll();\n				if (visitor.visit(node.key, node.value)) return;\n				if (node.left != null) {\n					queue.offer(node.left);\n				}\n				if (node.right != null) {\n					queue.offer(node.right);\n				}\n			}\n		}\n	}\n	private void resize() {\n		// 装填因子 <= 0.75,，节点总数量/ 哈希表桶数组长度，也叫做负载因子，如果装填因子超过0.75，就扩容为原来的2倍\n		if(size/table.length<=DEFAULT_LOAO_FACTOR) return;\n		Node<K, V>[] oldTable = table;\n		table=new Node[oldTable.length<<1];//扩容为原来的2倍\n		Queue<Node<K, V>> queue = new LinkedList<>();\n		for(int i = 0;i<oldTable.length;i++) {\n			if(oldTable[i]==null) continue;\n			queue.offer(oldTable[i]);\n			while(!queue.isEmpty()) {\n				Node<K, V> node = queue.poll();\n				if (node.left != null) {\n					queue.offer(node.left);\n				}\n				if (node.right != null) {\n					queue.offer(node.right);\n				}\n				// 挪动代码得放到最后面\n				moveNode(node);\n			}\n		}\n	}\n	private void moveNode(Node<K, V> newNode) {\n		// 重置\n		newNode.parent = null;\n		newNode.left = null;\n		newNode.right = null;\n		newNode.color = RED;\n		int index = index(newNode);\n		// 取出index位置的红黑树根节点\n		Node<K, V> root = table[index];\n		if (root == null) {\n			root = newNode;\n			table[index] = root;\n			fixAfterPut(root);\n			return;\n		}\n		// 添加新的节点到红黑树上面\n		Node<K, V> parent = root;\n		Node<K, V> node = root;\n		int cmp = 0;\n		K k1 = newNode.key;\n		int h1 = newNode.hash;\n		do {\n			parent = node;\n			K k2 = node.key;\n			int h2 = node.hash;\n			if (h1 > h2) {\n				cmp = 1;\n			} else if (h1 < h2) {\n				cmp = -1;\n			} else if (k1 != null && k2 != null \n					&& k1 instanceof Comparable\n					&& k1.getClass() == k2.getClass()\n					&& (cmp = ((Comparable)k1).compareTo(k2)) != 0) {\n			} else {\n				cmp = System.identityHashCode(k1) - System.identityHashCode(k2);\n			}\n			if (cmp > 0) {\n				node = node.right;\n			} else if (cmp < 0) {\n				node = node.left;\n			}\n		} while (node != null);\n		// 看看插入到父节点的哪个位置\n		newNode.parent = parent;\n		if (cmp > 0) {\n			parent.right = newNode;\n		} else {\n			parent.left = newNode;\n		}\n		\n		// 新添加节点之后的处理\n		fixAfterPut(newNode);\n	}\n	private Node<K, V> node(K key){\n		Node<K, V> root = table[index(key)];\n		return root == null?null:node(root,key);\n	}\n	private Node<K, V> node(Node<K, V> node, K k1) {\n		int h1 = hash(k1);\n		//存储查找结果\n		Node<K, V> result = null;\n		int cmp = 0;\n		while (node!=null) {\n			K k2 = node.key;\n			int h2 = node.hash;\n			//先比较哈希值\n			if(h1>h2) {\n				node=node.right;\n			}else if(h1<h2) {\n				node=node.left;\n			}else if(Objects.equals(k1, k2)) {//比较equals\n				return node;\n			}else if(k1 !=null && k2!=null\n					&& k1.getClass()==k2.getClass()//同一种类型并且具备可比较性\n					&& k1 instanceof Comparable\n					&& (cmp = ((Comparable) k1).compareTo(k2)) != 0) {\n				node=cmp>0?node.right:node.left;\n			}else if(node.right!=null && (result = node(node.right,k1))!=null) {//扫描右子树\n				return result;\n			}else {\n				// 只能往左边找\n				node = node.left;\n			}\n//			} else if (node.left != null && (result = node(node.left, k1)) != null) { \n//			return result;\n//		    } else {\n//			return null;\n//		    }\n	}\n	return null;\n	}\n	/**哈希函数实现步骤：一先生成Key的哈希值（必须是整数），二再让key的哈希值跟数组的大小进行相关运算，生成索引值\n	 * 根据key生成对应的索引（在桶数组中的位置）\n	 *  (hash ^ (hash >>> 16))为扰动计算\n	 *  & 位运算，取代%运算（前提是数组长度为2的幕2^n），\n	 */\n	private int hash(K key) {\n		if(key==null) return 0;\n		int hash = key.hashCode(); \n		return hash ^ (hash >>> 16);\n	}\n	private int index(K key) {\n		return hash(key) & (table.length-1);\n	}\n	private int index(Node<K, V> node) {\n		return node.hash & (table.length-1);\n	}\n	private V remove(Node<K, V> node) {\n		if (node == null) return null;\n		size--;\n		V oldValue = node.value;\n		if (node.hasTwoChildren()) { // 度为2的节点\n			// 找到后继节点\n			Node<K, V> s = successor(node);\n			// 用后继节点的值覆盖度为2的节点的值\n			node.key = s.key;\n			node.value = s.value;\n			node.hash = s.hash;\n			// 删除后继节点\n			node = s;\n		}\n		// 删除node节点（node的度必然是1或者0）\n		Node<K, V> replacement = node.left != null ? node.left : node.right;\n		int index = index(node);\n		if (replacement != null) { // node是度为1的节点\n			// 更改parent\n			replacement.parent = node.parent;\n			// 更改parent的left、right的指向\n			if (node.parent == null) { // node是度为1的节点并且是根节点\n				table[index] = replacement;\n			} else if (node == node.parent.left) {\n				node.parent.left = replacement;\n			} else { // node == node.parent.right\n				node.parent.right = replacement;\n			}\n			// 删除节点之后的处理\n			fixAfterRemove(replacement);\n		} else if (node.parent == null) { // node是叶子节点并且是根节点\n			table[index] = null;\n		} else { // node是叶子节点，但不是根节点\n			if (node == node.parent.left) {\n				node.parent.left = null;\n			} else { // node == node.parent.right\n				node.parent.right = null;\n			}\n			// 删除节点之后的处理\n			fixAfterRemove(node);\n		}\n		return oldValue;\n	}\n	private Node<K, V> successor(Node<K, V> node) {\n		if (node == null) return null;\n		// 前驱节点在左子树当中（right.left.left.left....）\n		Node<K, V> p = node.right;\n		if (p != null) {\n			while (p.left != null) {\n				p = p.left;\n			}\n			return p;\n		}\n		// 从父节点、祖父节点中寻找前驱节点\n		while (node.parent != null && node == node.parent.right) {\n			node = node.parent;\n		}\n		return node.parent;\n	}\n	private void  fixAfterRemove(Node<K, V> node) {\n		// 如果删除的节点是红色\n		// 或者 用以取代删除节点的子节点是红色\n		if (isRed(node)) {\n			black(node);\n			return;\n		}\n		Node<K, V> parent = node.parent;\n		if (parent == null) return;\n		// 删除的是黑色叶子节点【下溢】\n		// 判断被删除的node是左还是右\n		boolean left = parent.left == null || node.isLeftChild();\n		Node<K, V> sibling = left ? parent.right : parent.left;\n		if (left) { // 被删除的节点在左边，兄弟节点在右边\n			if (isRed(sibling)) { // 兄弟节点是红色\n				black(sibling);\n				red(parent);\n				rotateLeft(parent);\n				// 更换兄弟\n				sibling = parent.right;\n			}\n			// 兄弟节点必然是黑色\n			if (isBlack(sibling.left) && isBlack(sibling.right)) {\n				// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并\n				boolean parentBlack = isBlack(parent);\n				black(parent);\n				red(sibling);\n				if (parentBlack) {\n					fixAfterRemove(parent);\n				}\n			} else { // 兄弟节点至少有1个红色子节点，向兄弟节点借元素\n				// 兄弟节点的左边是黑色，兄弟要先旋转\n				if (isBlack(sibling.right)) {\n					rotateRight(sibling);\n					sibling = parent.right;\n				}\n			   color(sibling, colorOf(parent));\n				black(sibling.right);\n				black(parent);\n				rotateLeft(parent);\n			}\n		} else { // 被删除的节点在右边，兄弟节点在左边\n			if (isRed(sibling)) { // 兄弟节点是红色\n				black(sibling);\n				red(parent);\n				rotateRight(parent);\n				// 更换兄弟\n				sibling = parent.left;\n			}\n			// 兄弟节点必然是黑色\n			if (isBlack(sibling.left) && isBlack(sibling.right)) {\n				// 兄弟节点没有1个红色子节点，父节点要向下跟兄弟节点合并\n				boolean parentBlack = isBlack(parent);\n				black(parent);\n				red(sibling);\n				if (parentBlack) {\n					fixAfterRemove(parent);\n				}\n			} else { // 兄弟节点至少有1个红色子节点，向兄弟节点借元素\n				// 兄弟节点的左边是黑色，兄弟要先旋转\n				if (isBlack(sibling.left)) {\n					rotateLeft(sibling);\n					sibling = parent.left;\n				}\n				color(sibling, colorOf(parent));\n				black(sibling.left);\n				black(parent);\n				rotateRight(parent);\n			}\n		}\n	}\n	private void fixAfterPut (Node<K, V> node) {\n		Node<K, V> parent = node.parent;\n		// 添加的是根节点 或者 上溢到达了根节点\n		if (parent == null) {\n			black(node);\n			return;\n		}\n		// 如果父节点是黑色，直接返回\n		if (isBlack(parent)) return;\n		// 叔父节点\n		Node<K, V> uncle = parent.sibling();\n		// 祖父节点\n		Node<K, V> grand = red(parent.parent);\n		if (isRed(uncle)) { // 叔父节点是红色【B树节点上溢】\n			black(parent);\n			black(uncle);\n			// 把祖父节点当做是新添加的节点\n			fixAfterPut(grand);\n			return;\n		}\n		// 叔父节点不是红色\n		if (parent.isLeftChild()) { // L\n			if (node.isLeftChild()) { // LL\n				black(parent);\n			} else { // LR\n				black(node);\n				rotateLeft(parent);\n			}\n			rotateRight(grand);\n		} else { // R\n			if (node.isLeftChild()) { // RL\n				black(node);\n				rotateRight(parent);\n			} else { // RR\n				black(parent);\n			}\n			rotateLeft(grand);\n		}\n	}\n	private void rotateLeft(Node<K, V> grand) {\n		Node<K, V> parent = grand.right;\n		Node<K, V> child = parent.left;\n		grand.right = child;\n		parent.left = grand;\n		afterRotate(grand, parent, child);\n	}\n	private void rotateRight(Node<K, V> grand) {\n		Node<K, V> parent = grand.left;\n		Node<K, V> child = parent.right;\n		grand.left = child;\n		parent.right = grand;\n		afterRotate(grand, parent, child);\n	}\n	private void afterRotate(Node<K, V> grand, Node<K, V> parent, Node<K, V> child) {\n		// 让parent称为子树的根节点\n		parent.parent = grand.parent;\n		if (grand.isLeftChild()) {\n			grand.parent.left = parent;\n		} else if (grand.isRightChild()) {\n			grand.parent.right = parent;\n		} else { // grand是root节点\n			table[index(grand)] = parent;\n		}\n		// 更新child的parent\n		if (child != null) {\n			child.parent = grand;\n		}\n		// 更新grand的parent\n		grand.parent = parent;\n	}\n	private Node<K, V> color(Node<K, V> node, boolean color) {\n		if (node == null) return node;\n		node.color = color;\n		return node;\n	}\n	private Node<K, V> red(Node<K, V> node) {\n		return color(node, RED);\n	}\n	private Node<K, V> black(Node<K, V> node) {\n		return color(node, BLACK);\n	}\n	private boolean colorOf(Node<K, V> node) {\n		return node == null ? BLACK : node.color;\n	}\n	private boolean isBlack(Node<K, V> node) {\n		return colorOf(node) == BLACK;\n	}\n	private boolean isRed(Node<K, V> node) {\n		return colorOf(node) == RED;\n	}\n	protected static class Node<K,V>{\n		int hash;\n		K key;\n		V value;\n		boolean color = RED;\n		Node<K,V> left;\n		Node<K,V> right;\n		Node<K,V> parent;\n		public Node(K key, V value,Node<K, V> parent) {\n			this.key = key;\n			int hash = key == null ? 0 : key.hashCode();\n			this.hash = hash ^ (hash >>> 16);//提前生死哈希值，减少其他地方的计算次数\n			this.value = value;\n			this.parent = parent;\n		}\n		public boolean hasTwoChildren() {\n			return left != null && right != null;\n		}\n		public boolean isLeftChild() {\n			return parent != null && this == parent.left;\n		}\n		public boolean isRightChild() {\n			return parent != null && this == parent.right;\n		}\n		public Node<K, V> sibling() {\n			if (isLeftChild()) {\n				return parent.right;\n			}\n			if (isRightChild()) {\n				return parent.left;\n			}\n			return null;\n		}\n		@Override\n		public String toString() {\n			return \"Node_\" + key + \"_\" + value;\n		}\n		\n	}\n\n}\n\n```\n', '78', '1', '77', '0', '1', '0', '2020-06-29 14:40:00', '2020-06-29 14:40:00');
INSERT INTO `article` VALUES ('18', '数据结构--二叉堆与优先级队列', '学习记录，本篇主要内容是二叉堆与优先级队列', '九曜', '\n◼设计一种数据结构，用来存放整数，要求提供3 个接口\n***●添加元素●获取最大值●删除最大值***\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314152703889.png)\n◼有没有更优的数据结构？\n●堆✓获取最大值：O(1)、删除最大值：O(logn)、添加元素：O(logn)\n\n### ◼堆（Heap）\n\n也是一种树状的数据结构（不要跟内存模型中的“堆空间”混淆），常见的堆实现有：✓二叉堆（Binary Heap，完全二叉堆）✓多叉堆（D-heap、D-ary Heap）✓索引堆（Index Heap）✓二项堆（BinomialHeap）✓斐波那契堆（Fibonacci Heap）✓左倾堆（Leftist Heap，左式堆）✓斜堆（Skew Heap）![在这里插入图片描述](https://img-blog.csdnimg.cn/2020031415285516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n◼堆的一个重要**性质：任意节点的值总是≥（≤）子节点的值**\n●如果任意节点的值总是≥子节点的值，称为：最大堆、大根堆、大顶堆\n●如果任意节点的值总是≤子节点的值，称为：最小堆、小根堆、小顶堆\n◼由此可见，堆中的元素必须具备**可比较性**\n\n#### 二叉堆（Binary Heap）\n\n●二叉堆的逻辑结构就是一棵完全二叉树，所以也叫完全二叉堆\n●鉴于完全二叉树的一些特性，二叉堆的底层（物理结构）一般用数组实现即可![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314153311995.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n◼索引i 的规律（n 是元素数量）\n✓如果i = 0 ，它是根节点\n✓如果i > 0 ，它的父节点的索引为**floor( (i –1) / 2 )**\n✓如果2i + 1 ≤ n –1，它的**左子节点的索引为2i + 1**\n✓如果2i + 1 > n –1 ，它无左子节点\n✓如果2i + 2 ≤ n –1 ，它的**右子节点的索引为2i + 2**\n✓如果2i + 2 > n –1 ，它无右子节点\n\n◼获取最大值\n堆是返回得到堆顶元素\n所以如果是大顶堆则是数组第一个元素\n![](https://img-blog.csdnimg.cn/20200314154259778.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n◼最大堆–添加\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314154433873.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\n/**\n	 * 让index位置的元素上滤\n	 * @param index\n	 */\n	private void siftUp(int index) {\n		E element = elements[index];//得到该index位置的元素\n		while(index>0) {\n			int parentIndex = (index-1)>>1;//父节点的索引为floor( (i –1) / 2 )\n			E parent = elements[parentIndex];\n			if(compare(element, parent)<=0) break;\n			//将父元素存储在index位置\n			elements[index] = parent;\n			//重新赋值index\n			index = parentIndex;\n		}\n		elements[index] = element;//将循环最后得到的index位置 放上element值，完成上滤\n		\n	}\n```\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314154458852.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n◼最大堆–删除\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314154604489.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n```\n/**\n	 * 让index位置的元素下滤\n	 * @param index\n	 */\n	private void siftDown(int index) {\n		E element = elements[index];\n		int half = size>>1;\n		//第一个叶子节点的索引 == 非叶子节点的数量\n		//index 《 第一个叶子节点的索引  因为叶子节点不用下滤了\n		//所以必须保证index位置是非叶子节点\n		while(index<half) {\n			//index的节点只有两种情况，1.只有左节点   2.同时有左右节点\n			//默认是左节点进行比较\n			int childIndex = (index<<1)+1;//它的左子节点的索引为2i + 1\n			E child = elements[childIndex];\n			//右子节点\n			int rightIndex = childIndex+1;\n			//选出左右子节点最大的那个\n			if(rightIndex<size && compare(elements[rightIndex], child)>0) {\n				child = elements[childIndex = rightIndex];\n			}\n			//如果当前节点大于等于子节点 ，则退出\n			if(compare(element, child)>=0) break;\n			\n			//否则将子节点存放在index位置\n			elements[index] = child;\n			//重新设置index\n			index = childIndex;\n		}\n		elements[index] = element;\n	}\n```\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314154620975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n**◼最大堆–批量建堆（Heapify）**\n◼批量建堆，有2 种做法\n●自上而下的上滤\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314154726821.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n●自下而上的下滤\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200314154805239.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)\n**◼Top K问题**\n◼从n 个整数中，找出最大的前k 个数（k 远远小于n ）\n◼如果使用排序算法进行全排序，需要O(nlogn) 的时间复杂度\n◼如果使用二叉堆来解决，可以使用O(nlogk) 的时间复杂度来解决\n●新建一个小顶堆\n●扫描n 个整数\n✓先将遍历到的前k 个数放入堆中\n✓从第k + 1 个数开始，如果大于堆顶元素，就使用replace 操作（删除堆顶元素，将第k + 1 个数添加到堆中）\n●扫描完毕后，堆中剩下的就是最大的前k 个数\n```\n        // 新建一个小顶堆\n		BinaryHeap<Integer> heap = new BinaryHeap<>(new Comparator<Integer>() {\n			public int compare(Integer o1, Integer o2) {\n				return o2 - o1;\n			}\n		});\n		// 找出最大的前k个数\n		int k = 3;\n		Integer[] data = {51, 30, 39, 92, 74, 25, 16, 93, \n				91, 19, 54, 47, 73, 62, 76, 63, 35, 18, \n				90, 6, 65, 49, 3, 26, 61, 21, 48};\n		for (int i = 0; i < data.length; i++) {\n			if (heap.size() < k) { // 前k个数添加到小顶堆\n				heap.add(data[i]); // logk\n			} else if (data[i] > heap.get()) { // 如果是第k + 1个数，并且大于堆顶元素\n				heap.replace(data[i]); // logk\n			}\n		}\n```\n◼如果是找出最小的前k 个数呢？\n●用大顶堆\n●如果小于堆顶元素，就使用replace 操作\n\n#### ◼优先级队列（Priority Queue）\n\n◼优先级队列也是个队列\n◼普通的队列是FIFO 原则，也就是先进先出\n◼优先级队列则是按照**优先级高低**进行出队，比如将优先级最高的元素作为队头优先出队\n◼优先级队列的详细设计代码，二叉堆实现\n\n```\npublic class PriorityQueue<E> {\n	private BinaryHeap<E> heap;//二叉堆\n	public PriorityQueue(Comparator<E> comparator) {\n		heap = new BinaryHeap<>(comparator);\n	}\n	public PriorityQueue() {\n		this(null);\n	}\n	public int size() {\n		return heap.size();\n	}\n	public boolean isEmpty() {\n		return heap.isEmpty();\n	}\n	public void clear() {\n		heap.clear();\n	}\n	public void enQueue(E element) {\n		heap.add(element);\n	}\n	public E deQueue() {\n		return heap.remove();\n	}\n	public E front() {\n		return heap.get();\n	}\n}\n\n```\n◼二叉堆的详细设计代码\n```\npackage com.bj.heap;\n\nimport java.util.Comparator;\n\npublic class BinaryHeap2<E> {\n	private E[] elements;//数组\n	private static final int DEFAULT_CAPACITY=10;//默认大小\n	protected int size;\n    protected Comparator<E> comparator;\n	public BinaryHeap2(E[] elements, Comparator<E> comparator)  {\n		if (elements == null || elements.length == 0) {\n			this.elements = (E[]) new Object[DEFAULT_CAPACITY];\n		} else {\n			size = elements.length;\n			int capacity = Math.max(elements.length, DEFAULT_CAPACITY);\n			this.elements = (E[]) new Object[capacity];\n			for (int i = 0; i < elements.length; i++) {\n				this.elements[i] = elements[i];\n			}\n			heapify();\n		}\n	}\n	public BinaryHeap2(E[] elements)  {\n		this(elements, null);\n	}\n	public BinaryHeap2(Comparator<E> comparator) {\n		this(null, comparator);\n	}\n	public BinaryHeap2() {\n		this(null, null);\n	}\n	public int size() {\n		return size;\n	}\n	public boolean isEmpty() {\n		return size==0;\n	}\n	//清空\n	public void clear() {\n		for(int i = 0;i<size;i++) {\n			elements[i] = null;\n		}\n		size=0;\n	}\n\n	public void add(E element) {\n		elementNotNullCheck(element);\n		ensureCapacity(size + 1);\n		elements[size++] = element;//先往数组最后添加元素\n		siftUp(size-1);//再进行上滤\n		\n	}\n\n	//堆是返回得到堆顶元素\n	public E get() {\n		emptyCheck();\n		return elements[0];\n	}\n\n	public E remove() {\n        emptyCheck();\n		\n		int lastIndex = --size;\n		E root = elements[0];\n		elements[0] = elements[lastIndex];\n		elements[lastIndex] = null;\n		\n		siftDown(0);\n		return root;\n	}\n\n	// 删除堆顶元素的同时插入一个新元素\n	public E replace(E element) {\n		elementNotNullCheck(element);\n		E root = null;\n		if(size==0) {\n			elements[0] = element;\n			size++;\n		}else {\n			root = elements[0];\n			elements[0] = element;\n			siftDown(0);\n		}\n		return root;\n	}\n	\n	/**\n	 * 批量建堆\n	 */\n	private void heapify() {\n		// 自上而下的上滤\n//		for (int i = 1; i < size; i++) {\n//			siftUp(i);\n//		}\n		// 自下而上的下滤\n		for(int i =(size>>1)-1;i>=0;i--) {\n			siftDown(i);\n		}\n	}\n	\n	\n	/**\n	 * 让index位置的元素下滤\n	 * @param index\n	 */\n	private void siftDown(int index) {\n		E element = elements[index];\n		int half = size>>1;\n		//第一个叶子节点的索引 == 非叶子节点的数量\n		//index 《 第一个叶子节点的索引  因为叶子节点不用下滤了\n		//所以必须保证index位置是非叶子节点\n		while(index<half) {\n			//index的节点只有两种情况，1.只有左节点   2.同时有左右节点\n			//默认是左节点进行比较\n			int childIndex = (index<<1)+1;//它的左子节点的索引为2i + 1\n			E child = elements[childIndex];\n			\n			//右子节点\n			int rightIndex = childIndex+1;\n			\n			//选出左右子节点最大的那个\n			if(rightIndex<size && compare(elements[rightIndex], child)>0) {\n				child = elements[childIndex = rightIndex];\n			}\n			//如果当前节点大于等于子节点 ，则退出\n			if(compare(element, child)>=0) break;\n			\n			//否则将子节点存放在index位置\n			elements[index] = child;\n			//重新设置index\n			index = childIndex;\n		}\n		elements[index] = element;\n	}\n	\n	/**\n	 * 让index位置的元素上滤\n	 * @param index\n	 */\n	private void siftUp(int index) {\n		E element = elements[index];//得到该index位置的元素\n		while(index>0) {\n			int parentIndex = (index-1)>>1;//父节点的索引为floor( (i –1) / 2 )\n			E parent = elements[parentIndex];\n			if(compare(element, parent)<=0) break;\n			//将父元素存储在index位置\n			elements[index] = parent;\n			//重新赋值index\n			index = parentIndex;\n		}\n		elements[index] = element;//将循环最后得到的index位置 放上element值，完成上滤\n		\n	}\n\n	//扩容\n	private void ensureCapacity(int capacity) {\n		int oldCapacity = elements.length;\n		if(oldCapacity>=capacity) return;\n		\n		//新容量为旧容量的1.5倍\n		int newCapacity = oldCapacity + (oldCapacity>>1);\n		E[] newElements = (E[]) new Object[newCapacity];\n		for(int i =0;i<size;i++) {\n			newElements[i] = elements[i];\n		}\n		elements = newElements;\n	}\n	\n	//检查是否有值\n	private void emptyCheck() {\n		if (size == 0) {\n			throw new IndexOutOfBoundsException(\"Heap is empty\");\n		}\n	}\n	//检查元素是否为空\n	private void elementNotNullCheck(E element) {\n		if (element == null) {\n			throw new IllegalArgumentException(\"element must not be null\");\n		}\n	}\n	private int compare(E e1, E e2) {\n		return comparator != null ? comparator.compare(e1, e2) \n				: ((Comparable<E>)e1).compareTo(e2);\n	}\n}\n\n\n```\n', '77', '2', '66', '1', '13', '0', '2020-06-29 14:40:44', '2020-06-29 14:40:44');
INSERT INTO `article` VALUES ('19', '数据结构--Trie', '以下记录，本篇主要内容是Trie', '九曜', '\n\n#### ◼Trie\n\n●Trie 也叫做字典树、前缀树（Prefix Tree）、单词查找树\n●Trie 搜索字符串的效率主要跟字符串的长度有关\n假设使用Trie 存储cat、dog、doggy、does、cast、add 六个单词\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200315151051297.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ0OTYxMTQ5,size_16,color_FFFFFF,t_70)◼Trie 的优点：搜索前缀的效率主要跟前缀的长度有关\n◼Trie 的缺点：需要耗费大量的内存，因此还有待改进\n●更多Trie 相关的数据结构和算法\n✓Double-array Trie、Suffix Tree、Patricia Tree、Crit-bit Tree、AC自动机\n\n◼接口设计\nint size();\nboolean isEmpty();\nvoid clear();\nboolean contains(String str);\nV add(String str, V value);\nV remove(String str);\nboolean starsWith(String prefix);\n◼Trie详细设计\n```\nimport java.util.HashMap;\npublic class Trie<V> {\n	private int size;\n	private Node<V> root ;\n	public int size() {\n		return size;\n	}\n	public boolean isEmpty() {\n		return size == 0;\n	}\n	public void clear() {\n		size=0;\n		root=null;\n	}\n	public V get(String key) {\n		Node<V> node = node(key);\n		return node != null && node.word?node.value:null; \n	}\n	public boolean contains(String key) {\n		Node<V> node = node(key);\n		return node!= null && node.word;\n	}\n	public V add(String key, V value) {\n		keyCheck(key);\n		//创建根节点\n		if(root==null) {\n			root=new Node<>(null);\n		}\n		Node<V> node =root;\n		int len = key.length();\n		for (int i = 0; i < len; i++) {\n			char c = key.charAt(i); \n			boolean emptyChildren = node.children ==null;\n			Node<V> childNode = emptyChildren?null:node.children.get(c);\n			if(childNode ==null) {\n				childNode = new Node<>(node);\n				childNode.character=c;\n				node.children = emptyChildren?new HashMap<>():node.children;\n				node.children.put(c, childNode);\n			}\n			node = childNode;\n		}\n		if (node.word) { // 已经存在这个单词\n			V oldValue= node.value;\n			node.value=value;\n			return oldValue;\n		}\n		// 新增一个单词\n		node.word=true;\n		node.value=value;\n		size++;\n		return null;\n	}\n	public V remove(String key) {\n		//找到最后一个节点\n		Node<V> node = node(key);\n		//如果不是单词结尾，不做任何处理\n		if(node ==null || !node.word) return null;\n		size--;\n		V oldValue = node.value;\n		//如果还有子节点\n		if(node.children!=null && !node.children.isEmpty()) {\n			node.word=false;\n			node.value=null;\n			return oldValue;\n		}\n		//如果没有子节点\n		Node<V> parent = null;\n		while((parent=node.parent)!=null) {\n			parent.children.remove(node.character);\n			if(parent.word || parent.children.size()>0) break;\n			node = parent;\n		}\n		return oldValue;\n	}\n	public boolean startsWith(String prefix) {\n		return node(prefix)!=null;\n	}\n	private Node<V> node(String key) {\n		keyCheck(key);\n		Node<V> node = root;\n		int len = key.length();\n		for(int i = 0;i<len;i++) {\n			if(node==null || node.children==null || node.children.isEmpty()) return null;\n			char c = key.charAt(i);\n			node = node.children.get(c);\n		}\n		return node;\n	}\n	private void keyCheck(String key) {\n		if (key == null || key.length() == 0) {\n			throw new IllegalArgumentException(\"key must not be empty\");\n		}\n	}\n	private static class Node<V>{\n		Node<V> parent;\n		HashMap<Character, Node<V>> children;\n		Character character;\n		V value;\n		boolean word;// 是否为单词的结尾（是否为一个完整的单词）\n		public Node(Node<V> parent) {\n			this.parent=parent;\n		}\n	}\n}\n\n```\n\n', '76', '3', '55', '0', '1', '0', '2020-06-29 14:41:18', '2020-06-29 14:41:18');

-- ----------------------------
-- Table structure for comment
-- ----------------------------
DROP TABLE IF EXISTS `comment`;
CREATE TABLE `comment` (
  `co_id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '评论者姓名',
  `email` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '邮箱',
  `content` varchar(128) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL COMMENT '内容',
  `is_delete` tinyint(1) NOT NULL DEFAULT '0' COMMENT '是否逻辑删除',
  `aricle_id` int DEFAULT NULL COMMENT '父节点',
  `ip_address` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT 'IP地址',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`co_id`) USING BTREE,
  KEY `comment_ibfk_2` (`aricle_id`) USING BTREE,
  KEY `comment_ibfk_3` (`ip_address`) USING BTREE
) ENGINE=InnoDB AUTO_INCREMENT=57 DEFAULT CHARSET=utf8 ROW_FORMAT=DYNAMIC;

-- ----------------------------
-- Records of comment
-- ----------------------------
INSERT INTO `comment` VALUES ('1', '游客one', '1333333@qq.com', '文章不错点赞！', '0', '1', '192.168.0.1', '2019-06-23 13:09:35', '2020-06-09 14:59:30');
INSERT INTO `comment` VALUES ('2', '游客two', '456798@qqcom', '随便说点什么吧！！！', '0', '1', '192.168.0.12', '2019-06-23 13:10:09', '2020-06-09 14:59:33');
INSERT INTO `comment` VALUES ('3', '雷浩', '123456@qq.com', '内容内容内容内容内容内容', '0', '1', '192.168.0.13', '2019-06-24 00:00:00', '2020-06-09 14:59:35');
INSERT INTO `comment` VALUES ('4', '测试', '123@qq.com', 'ceshi', '0', '1', '192.168.0.14', '2019-11-16 05:51:01', '2020-06-09 14:59:36');
INSERT INTO `comment` VALUES ('5', '测试二', '111@qq.com', '哈哈', '0', '1', '192.168.0.15', '2019-11-16 05:51:01', '2020-06-09 14:59:38');
INSERT INTO `comment` VALUES ('6', '王五', '555@qq.com', '回复雷浩', '0', '3', '192.168.0.16', '2019-11-09 12:25:05', '2020-06-09 14:59:41');
INSERT INTO `comment` VALUES ('7', '阿斯', '2910819096@qq.com', '66666', '0', '3', '192.168.0.17', '2019-11-09 12:28:51', '2020-06-09 14:59:43');
INSERT INTO `comment` VALUES ('8', '77', '775736156@qq.com', '777', '0', '3', '192.168.0.18', '2019-11-09 12:30:43', '2020-06-09 14:59:45');
INSERT INTO `comment` VALUES ('9', '888', '365651975@qq.com', '回复77', '0', '2', '192.168.0.19', '2019-11-09 12:31:57', '2020-06-09 14:59:47');
INSERT INTO `comment` VALUES ('12', '阿飞', '775736156@qq.com', '啊哈哈', '0', '2', '192.168.0.10', '2019-11-10 01:12:44', '2020-06-09 14:59:50');

-- ----------------------------
-- Table structure for link
-- ----------------------------
DROP TABLE IF EXISTS `link`;
CREATE TABLE `link` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `title` varchar(50) DEFAULT NULL COMMENT '链接名称',
  `url` varchar(500) DEFAULT NULL COMMENT '链接地址',
  `avatar` varchar(255) DEFAULT NULL COMMENT '头像',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 COMMENT='友链';

-- ----------------------------
-- Records of link
-- ----------------------------
INSERT INTO `link` VALUES ('1', 'csdn', 'https://blog.csdn.net/qq_44961149', '', '2020-06-09 19:55:00', '2020-06-11 11:13:25');
INSERT INTO `link` VALUES ('2', '掘金', 'https://juejin.im/user/5edf78ddf265da76ed486231', 'https://b-gold-cdn.xitu.io/v3/static/img/logo.a7995ad.svg', '2020-06-09 20:00:35', '2020-06-09 20:00:35');
INSERT INTO `link` VALUES ('3', 'GitHub', 'https://github.com/15626862046', null, '2020-06-14 16:07:50', '2020-06-14 16:07:50');

-- ----------------------------
-- Table structure for log
-- ----------------------------
DROP TABLE IF EXISTS `log`;
CREATE TABLE `log` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `ip` varchar(64) CHARACTER SET utf8 COLLATE utf8_general_ci DEFAULT NULL COMMENT 'IP地址',
  `method` varchar(200) DEFAULT NULL COMMENT '请求方法',
  `params` varchar(5000) DEFAULT NULL COMMENT '请求参数',
  `time` bigint DEFAULT NULL COMMENT '执行时长(毫秒)',
  `create_date` timestamp NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8 COMMENT='阅读日志';

-- ----------------------------
-- Records of log
-- ----------------------------
INSERT INTO `log` VALUES ('1', '47.100.64.9', '/user/', '[1]', '30', '2020-06-09 20:57:11');
INSERT INTO `log` VALUES ('2', '188.92.15.117', '/user/', '[1]', '10', '2020-06-09 20:58:04');
INSERT INTO `log` VALUES ('3', '192.168.1.1', '/user/', '[1]', '5', '2020-06-09 21:00:45');
INSERT INTO `log` VALUES ('4', '192.168.1.1', '/tag/', '[1]', '1', '2020-06-09 21:00:48');
INSERT INTO `log` VALUES ('5', '192.168.1.1', '/comment/', '[1]', '2', '2020-06-09 21:00:50');

-- ----------------------------
-- Table structure for menu
-- ----------------------------
DROP TABLE IF EXISTS `menu`;
CREATE TABLE `menu` (
  `menu_id` bigint NOT NULL AUTO_INCREMENT,
  `parent_id` bigint DEFAULT NULL,
  `name` tinytext,
  `url` varchar(200) DEFAULT NULL,
  `perms` varchar(500) DEFAULT NULL,
  `type` int DEFAULT NULL,
  `icon` tinytext,
  `order_num` int DEFAULT NULL,
  PRIMARY KEY (`menu_id`)
) ENGINE=InnoDB AUTO_INCREMENT=85 DEFAULT CHARSET=utf8 COMMENT='菜单管理';

-- ----------------------------
-- Records of menu
-- ----------------------------
INSERT INTO `menu` VALUES ('1', '0', '系统管理', null, null, '0', 'config', '3');
INSERT INTO `menu` VALUES ('2', '1', '管理员列表', 'sys/user', null, '1', 'admin', '1');
INSERT INTO `menu` VALUES ('3', '1', '角色管理', 'sys/role', null, '1', 'role', '2');
INSERT INTO `menu` VALUES ('4', '1', '菜单管理', 'sys/menu', null, '1', 'menu', '3');
INSERT INTO `menu` VALUES ('5', '1', 'SQL监控', 'http://localhost:8080/dbblog/druid/sql.html', null, '1', 'config', '5');
INSERT INTO `menu` VALUES ('15', '2', '查看', null, 'sys:user:list,sys:user:info', '2', null, '0');
INSERT INTO `menu` VALUES ('16', '2', '新增', null, 'sys:user:save,sys:role:select', '2', null, '0');
INSERT INTO `menu` VALUES ('17', '2', '修改', null, 'sys:user:update,sys:role:select', '2', null, '0');
INSERT INTO `menu` VALUES ('18', '2', '删除', null, 'sys:user:delete', '2', null, '0');
INSERT INTO `menu` VALUES ('19', '3', '查看', null, 'sys:role:list,sys:role:info', '2', null, '0');
INSERT INTO `menu` VALUES ('20', '3', '新增', null, 'sys:role:save,sys:menu:list', '2', null, '0');
INSERT INTO `menu` VALUES ('21', '3', '修改', null, 'sys:role:update,sys:menu:list', '2', null, '0');
INSERT INTO `menu` VALUES ('22', '3', '删除', null, 'sys:role:delete', '2', null, '0');
INSERT INTO `menu` VALUES ('23', '4', '查看', null, 'sys:menu:list,sys:menu:info', '2', null, '0');
INSERT INTO `menu` VALUES ('24', '4', '新增', null, 'sys:menu:save,sys:menu:select', '2', null, '0');
INSERT INTO `menu` VALUES ('25', '4', '修改', null, 'sys:menu:update,sys:menu:select', '2', null, '0');
INSERT INTO `menu` VALUES ('26', '4', '删除', null, 'sys:menu:delete', '2', null, '0');
INSERT INTO `menu` VALUES ('30', '0', '博文管理', null, null, '0', 'article', '0');
INSERT INTO `menu` VALUES ('31', '30', '新增博文', 'article/article-add-or-update', 'article:save,article:update', '1', 'add', '0');
INSERT INTO `menu` VALUES ('32', '30', '博文列表', 'article/article', null, '1', 'list', '0');
INSERT INTO `menu` VALUES ('33', '32', '删除', null, 'article:delete', '2', null, '0');
INSERT INTO `menu` VALUES ('34', '32', '查看', null, 'article:list', '2', null, '0');
INSERT INTO `menu` VALUES ('38', '43', '分类管理', 'operation/category', null, '1', 'category', '6');
INSERT INTO `menu` VALUES ('39', '38', '查看', null, 'operation:category:list,operation:category:info', '2', null, '6');
INSERT INTO `menu` VALUES ('40', '38', '新增', null, 'operation:category:save', '2', null, '6');
INSERT INTO `menu` VALUES ('41', '38', '修改', null, 'operation:category:update', '2', null, '6');
INSERT INTO `menu` VALUES ('42', '38', '删除', null, 'operation:category:delete', '2', null, '6');
INSERT INTO `menu` VALUES ('43', '0', '运营管理', null, null, '0', 'operation', '2');
INSERT INTO `menu` VALUES ('45', '1', '系统参数', 'sys/param', null, '1', 'param', '4');
INSERT INTO `menu` VALUES ('46', '45', '查看', null, 'sys:param:list,sys:param:info', '2', null, '6');
INSERT INTO `menu` VALUES ('47', '45', '新增', null, 'sys:param:save', '2', null, '6');
INSERT INTO `menu` VALUES ('48', '45', '修改', null, 'sys:param:update', '2', null, '6');
INSERT INTO `menu` VALUES ('49', '45', '删除', null, 'sys:param:delete', '2', null, '6');
INSERT INTO `menu` VALUES ('50', '43', '标签管理', 'operation/tag', null, '1', 'tag', '6');
INSERT INTO `menu` VALUES ('51', '50', '查看', null, 'operation:tag:list,operation:tag:info', '2', null, '6');
INSERT INTO `menu` VALUES ('52', '50', '新增', null, 'operation:tag:save', '2', null, '6');
INSERT INTO `menu` VALUES ('53', '50', '修改', null, 'operation:tag:update', '2', null, '6');
INSERT INTO `menu` VALUES ('54', '50', '删除', null, 'operation:tag:delete', '2', null, '6');
INSERT INTO `menu` VALUES ('61', '66', '图书管理', 'book/book', null, '1', 'list', '3');
INSERT INTO `menu` VALUES ('62', '61', '查看', null, 'book:list,book:info', '2', null, '6');
INSERT INTO `menu` VALUES ('63', '61', '新增', null, 'book:save', '2', null, '6');
INSERT INTO `menu` VALUES ('64', '61', '修改', null, 'book:update', '2', null, '6');
INSERT INTO `menu` VALUES ('65', '61', '删除', null, 'book:delete', '2', null, '6');
INSERT INTO `menu` VALUES ('66', '0', '阅读管理', null, null, '0', 'read', '1');
INSERT INTO `menu` VALUES ('67', '66', '新增图书', 'book/book-add-or-update', '', '1', 'add', '1');
INSERT INTO `menu` VALUES ('68', '66', '笔记管理', 'book/note', null, '1', 'list', '2');
INSERT INTO `menu` VALUES ('69', '68', '查看', null, 'book:note:list,book:note:info', '2', null, '6');
INSERT INTO `menu` VALUES ('70', '68', '新增', null, 'book:note:save', '2', null, '6');
INSERT INTO `menu` VALUES ('71', '68', '修改', null, 'book:note:update', '2', null, '6');
INSERT INTO `menu` VALUES ('72', '68', '删除', null, 'book:note:delete', '2', null, '6');
INSERT INTO `menu` VALUES ('73', '66', '新增笔记', 'book/note-add-or-update', '', '1', 'add', '0');
INSERT INTO `menu` VALUES ('74', '43', '友链管理', 'operation/link', null, '1', 'link', '6');
INSERT INTO `menu` VALUES ('75', '74', '查看', null, 'operation:link:list,operation:link:info', '2', null, '6');
INSERT INTO `menu` VALUES ('76', '74', '新增', null, 'operation:link:save', '2', null, '6');
INSERT INTO `menu` VALUES ('77', '74', '修改', null, 'operation:link:update', '2', null, '6');
INSERT INTO `menu` VALUES ('78', '74', '删除', null, 'operation:link:delete', '2', null, '6');
INSERT INTO `menu` VALUES ('79', '43', '推荐管理', 'operation/recommend', null, '1', 'recommend', '6');
INSERT INTO `menu` VALUES ('80', '79', '查看', null, 'operation:recommend:list,operation:recommend:info', '2', null, '6');
INSERT INTO `menu` VALUES ('81', '79', '新增', null, 'operation:recommend:save', '2', null, '6');
INSERT INTO `menu` VALUES ('82', '79', '修改', null, 'operation:recommend:update', '2', null, '6');
INSERT INTO `menu` VALUES ('83', '79', '删除', null, 'operation:recommend:delete', '2', null, '6');
INSERT INTO `menu` VALUES ('84', '32', '刷新缓存', null, 'article:cache:refresh', '2', null, '0');

-- ----------------------------
-- Table structure for recommend
-- ----------------------------
DROP TABLE IF EXISTS `recommend`;
CREATE TABLE `recommend` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `link_id` int DEFAULT NULL COMMENT '推荐的文章Id',
  `type` int DEFAULT NULL COMMENT '推荐类型',
  `order_num` int DEFAULT '0' COMMENT '顺序',
  `title` varchar(100) COLLATE utf8mb4_general_ci DEFAULT NULL COMMENT '标题',
  `top` tinyint(1) DEFAULT '0' COMMENT '置顶',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_general_ci COMMENT='推荐';

-- ----------------------------
-- Records of recommend
-- ----------------------------

-- ----------------------------
-- Table structure for role
-- ----------------------------
DROP TABLE IF EXISTS `role`;
CREATE TABLE `role` (
  `role_id` bigint NOT NULL AUTO_INCREMENT,
  `role_name` varchar(100) DEFAULT NULL COMMENT '角色名称',
  `remark` varchar(100) DEFAULT NULL COMMENT '备注',
  `create_user_id` bigint DEFAULT NULL COMMENT '创建者ID',
  `create_time` datetime DEFAULT NULL COMMENT '创建时间',
  PRIMARY KEY (`role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='角色';

-- ----------------------------
-- Records of role
-- ----------------------------

-- ----------------------------
-- Table structure for role_menu
-- ----------------------------
DROP TABLE IF EXISTS `role_menu`;
CREATE TABLE `role_menu` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `role_id` bigint DEFAULT NULL COMMENT '角色ID',
  `menu_id` bigint DEFAULT NULL COMMENT '菜单ID',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='角色与菜单对应关系';

-- ----------------------------
-- Records of role_menu
-- ----------------------------

-- ----------------------------
-- Table structure for tag
-- ----------------------------
DROP TABLE IF EXISTS `tag`;
CREATE TABLE `tag` (
  `id` int NOT NULL AUTO_INCREMENT,
  `name` varchar(50) DEFAULT NULL COMMENT '标签名字',
  `deleted` tinyint DEFAULT '0',
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=12 DEFAULT CHARSET=utf8 COMMENT='标签';

-- ----------------------------
-- Records of tag
-- ----------------------------
INSERT INTO `tag` VALUES ('1', '本站相关', '0', '2020-06-09 16:58:08', '2020-06-09 16:58:08');
INSERT INTO `tag` VALUES ('2', '数据结构与算法', '0', '2020-06-09 16:58:08', '2020-06-09 16:58:08');
INSERT INTO `tag` VALUES ('3', 'spring boot', '0', '2020-06-09 16:58:08', '2020-06-09 16:58:08');
INSERT INTO `tag` VALUES ('4', 'redis', '0', '2020-06-09 16:58:08', '2020-06-09 16:58:08');
INSERT INTO `tag` VALUES ('5', 'Java', '0', '2020-06-09 16:58:08', '2020-06-09 16:58:08');
INSERT INTO `tag` VALUES ('6', 'JVM', '0', '2020-06-09 16:58:08', '2020-06-09 16:58:08');
INSERT INTO `tag` VALUES ('7', '问题集', '0', '2020-06-09 16:58:08', '2020-06-09 16:58:08');
INSERT INTO `tag` VALUES ('8', '面试', '0', '2020-06-09 16:58:08', '2020-06-09 16:58:08');
INSERT INTO `tag` VALUES ('9', 'ElasticSearch', '0', '2020-06-09 16:58:08', '2020-06-09 16:58:08');
INSERT INTO `tag` VALUES ('10', 'MySQL', '0', '2020-06-09 16:58:08', '2020-06-09 16:58:08');
INSERT INTO `tag` VALUES ('11', 'mybatis', '0', '2020-06-11 10:18:24', '2020-06-11 10:18:24');

-- ----------------------------
-- Table structure for type
-- ----------------------------
DROP TABLE IF EXISTS `type`;
CREATE TABLE `type` (
  `id` int NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(255) DEFAULT NULL COMMENT '名称',
  `create_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '创建时间',
  `update_time` timestamp NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
  PRIMARY KEY (`id`),
  UNIQUE KEY `operation_category_id_uindex` (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=14 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of type
-- ----------------------------
INSERT INTO `type` VALUES ('1', '数据结构与算法', '2020-06-09 20:02:30', '2020-06-09 20:02:30');
INSERT INTO `type` VALUES ('2', 'Java', '2020-06-09 20:02:30', '2020-06-09 20:02:30');
INSERT INTO `type` VALUES ('3', 'vue', '2020-06-09 20:02:30', '2020-06-09 20:02:30');
INSERT INTO `type` VALUES ('13', '问题集', '2020-06-11 10:49:49', '2020-06-11 10:49:49');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `user_id` bigint NOT NULL AUTO_INCREMENT,
  `username` tinytext,
  `password` varchar(255) DEFAULT NULL,
  `email` tinytext,
  `salt` tinytext,
  `create_user_id` tinytext,
  `create_time` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `status` tinyint DEFAULT NULL,
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('1', 'admin', '21232f297a57a5a743894a0e4a801fc3', '731177205@qq.com', '', '1', '2020-06-07 16:40:21', '1');
INSERT INTO `user` VALUES ('2', 'jiuyao', 'e10adc3949ba59abbe56e057f20f883e', '731177205@qq.com', null, '2', '2020-06-06 16:41:50', '1');

-- ----------------------------
-- Table structure for user_role
-- ----------------------------
DROP TABLE IF EXISTS `user_role`;
CREATE TABLE `user_role` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `user_id` bigint DEFAULT NULL COMMENT '用户ID',
  `role_id` bigint DEFAULT NULL COMMENT '角色ID',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户与角色对应关系';

-- ----------------------------
-- Records of user_role
-- ----------------------------
